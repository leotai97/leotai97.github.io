<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-us">
<head>
<meta name="viewport" content="width=device-width"> 
<meta m_harset="utf-8" />
<title>Music Reference</title>
<style>

        body, html { margin:0; }
            select { font-size:2.60vw; }
             input { vertical-align:middle; font-size:2.4vw; }

           .radBtn { width:2.4vw; height:2.4vw; }

           .thInst { font-size:2.4vw; padding:2.4vw; }
           .tdInst { font-size:2.4vw; vertical-align:middle; padding:2.4vw; }

          .tabLink { background-color:#555; color:white; float:left; border:none; outline:none; cursor:pointer; padding:0.729vw 0.833vw; font-size:2.4vw; height:4.6vw; }
        
    .tabLink:hover { background-color:#777; }
       .tabContent { color:black; display:none; padding:5.208vw 1.042vw; width:100%; }

      .tdSideChord { width:3vw; }
        .tdVersion { font-size:1.8vw; }

         .fretCell { font-size:1.042vw; position:relative; color:#000044; text-align:center; height:2.3vw; }
     .fretCellLeft { font-size:0.938vw; position:absolute; top:1.344vw; left:0.1vw; color:#000044;}
    .fretCellRight { font-size:0.938vw; position:absolute; top:1.344vw; right:0.1vw; color:#000044; } 
       .fretString { outline:thin solid lightsteelblue; cursor:pointer; }
         .fretMark { font-size:0.938vw; text-align:center; }

       .pianoWhite { position:absolute; top:0; width:4vw; height:20vw; background-color:white; border:0.052vw solid black; }
   .pianoWhiteText { position:absolute; top:16vw; left:0.2vw; width:3.6vw; font-size:1.4vw; text-align:center; color:black; background-color:white; border:none; }

       .pianoBlack { position:absolute; top:0; width:2.4vw; height:13vw; background-color:black; }
   .pianoBlackText { position:absolute; top:9vw; left:0.2vw; width:2.0vw; font-size:1.4vw; text-align:center; color:white; background-color:black; border:none; }

        .chordInfo { font-size:1.042vw; padding:0.521vw; color:#000044; cursor:pointer; border:0.2vw solid lime; }
        .scaleInfo { font-size:1.022vw; padding:0.501vw; color:#000044; }
        .modeChord { border:0.052vw solid lightsteelblue; width:1.823vw; text-align:center; cursor:pointer; border:0.2vw solid lime; }
        .chordNote { border:0.2vw solid limegreen; width: 1.823vw; text-align: center; cursor:pointer; }
     .chordFormula { text-align:center; font-style:italic; font-size:0.93vw; }
        .chordStep { text-align:center; font-size:0.93vw; }
     .modeSequence { text-align:center; font-style:italic; font-size:0.938vw; }
        .scaleName { font-size:1.042vw; padding:0.501vw; cursor:pointer; border:0.2vw solid lime; }
        .scaleNote { border:0.052vw solid lightsteelblue; width:1.823vw; text-align:center; cursor:pointer; }
     .spanPatInKey { border:0.2vw solid limegreen; cursor:pointer; }

  .tableChordsRoot { border-spacing:0.9vw; }
     .tdChordsRoot { font-size:2.40vw; vertical-align:middle; text-align:center; width:4.0vw; height:3.2vw; border-radius:0.26vw; border:0.052vw solid black; cursor:pointer; color:black; background-color:#e9e9e9; }
                   
              .btn { font-size:2.50vw; font-weight:100; }

  .tableDlgPattern { border-spacing:2vw; }
     .tdDlgPattern { font-size:2.50vw; vertical-align:middle; text-align:center; width:32.0vw; height:4.0vw; border-radius:0.26vw; border:0.052vw solid black; cursor:pointer; color:black; background-color:#e9e9e9; }

       .dialogBase { display:none; position:fixed; z-index:1; left:0; top:0; width:100vw; height:100vh; overflow:visible; background-color:rgb(0,0,0); background-color:rgba(0,0,0,0.4); } /* opacity */
           .dialog { background-color:#fefefe; margin:7vw auto; padding:0.104vw; border:0.052vw solid #888; width:90vw; }
 
</style>
<script type="text/javascript">

// web audio api context


// special characters 

var symSharp='\u266F'; // Arial unicode MS
var symFlat='\u266D';  
var symDim7='\u00F8';  // 0 with slash
var symFDim='\u00B0';  // degree symbol
var symMajor='\u25B3'; // delta symbol
var symDot = '\u25CF'; // dot
var symNote = '\u266B'; // 2 notes
var symNot = '\u2205';  // circle with line thru it

// measurements in vw & vh viewport units

var fretStartSize = 5; // 80 pixels on 1920 x 1200
var fretBeforeNut = 2.604; // 50 pixels
var fretDecrease = 0.110;  // 2 pixel
var fretMarkStart = 3.126; // 60 pixels, slid over to line up dots
var fretMarkBeforeNut = 1.562; // 30 pixels

var pianoWhiteWidth = 4;   // width of a white piano key in "vw" viewport units  ( 4 = 4% of the view port width
var pianoWhiteHeight = 20; // height
var pianoBlackWidth = 2.8; // width of a black piano key

/////////////////////////////
//    Global Variables
/////////////////////////////

var m_Version = "1.0.3";
var m_Audio = null;              // used in frequency generation

var m_CurrentChordPattern = -1; // index to m_arrChordPatterns, set when cbo dropdown is changed
var m_CurrentKey = -1;          // index to m_arrModes.KeyList array, used to generate m_Key Key object
var m_CurrentMode = -1;         // index to m_arrModes, set when a cboMode dropdown is changed  
var m_CurrentInstrument = -1;   // index to m_arrInstruments, set when radio button is clicked
var m_CurrentChordRoot = -1;    // set when generated chord root note TD is clicked in Chord section, chord type dialog is popped and chord is generated
var m_CurrentMidiNote = -1;     // index to m_arrPlayMidi, it is used to cycle thru notes that are played when things are clicked

var m_CurrentGuitarCapo = 0;    // all set when capo drop downs are changed
var m_CurrentBassCapo = 0;
var m_CurrentMandolinCapo = 0;
var m_CurrentUkuleleCapo = 0;

var m_CurrentGuitarTuning = 0;   // all set when tuning dropdowns are changed
var m_CurrentBassTuning = 0;
var m_CurrentMandolinTuning = 0;
var m_CurrentUkuleleTuning = 0;
var m_CurrentKeyboardTuning = 0;

var m_Key = null;  // set to a Key object when a key is selected, contains list of notes in the key

var m_Guitar = 0;  // instrument index values for m_arrInstruments
var m_Bass = 1;
var m_Mandolin = 2;
var m_Ukulele = 3;
var m_Keyboard = 4;

var m_cpMajor=0;  // these variables can be used to access the specific elements of the m_arrChordPatterns array
var m_cpMinor=1;
var m_cpSus=2;
var m_cpAug=3;
var m_cpDim=4;
var m_cpMajor6=5;
var m_cpMinor6=6;
var m_cpMajor7=7;
var m_cpMinor7=8;
var m_cpDom7=9;
var m_cpHalfDim7=10;
var m_cpDim7=11;
var m_cpMajor9=12;
var m_cpMinor9=13;
var m_cpDom9=14;

// these variables can be used to access the specific elements of the m_arrModes array

var m_modeIonian = 0;      // Major
var m_modeAeolian = 5;     // Minor

var m_GuitarBarreChordE;  // the guitar barre chord pattern based on the open E chord
var m_GuitarBarreChordEm;  // the guitar barre chord pattern based on the open A chord
var m_GuitarBarreChordA;  // the guitar barre chord pattern based on the open A chord
var m_GuitarBarreChordAm;  // the guitar barre chord pattern based on the open A minor chord
var m_GuitarBarreChordAd   // A dim

var m_MandolinBarreChordD;  // based on open D chord
var m_MandolinBarreChordDm; // based on open D minor chord

// arrays

var m_arrInstruments = new Array();      // ID, Name, # of strings, # of frets

var m_arrChordPatterns = new Array();    // ID, Name, ShortName, Pitches, PitchCount, Root, Third, Fifth, Seventh, Ninth, Formula
var m_mapMidiNotes = new Map();
var m_arrMidiNotesHL = new Array();      // ID, Number, Offset, Octave, Frequency, MidiName, Name
var m_arrMidiNotesLH = new Array();      // Same as above
var m_arrModes = new Array();            // ID, ModeName, Sequences (steps), ChordType (the pattern), Background (color)

var m_arrGuitar = new Array();           // 2D array of midi notes for instrument fretboards
var m_arrBass = new Array();
var m_arrMandolin = new Array();
var m_arrUkulele = new Array();

// blue green gradient color array

var m_arrGradientBlueGreen = ["#189753", "#1ea55c", "#24b266", "#2ac06f", "#30cc79", "#36da82", "#42f696"];

// array of pastel colors for chord notes

var m_arrPastels = ["#b2cefe", "#baed91", "#faf884", "#f2a2e8"];     

var m_arrPlayMidi = new Array(); // array of midi note numbers that are played when things are clicked

//////////////////////////////////
//   Object Class Construction
//////////////////////////////////

function Instrument(id, name, strings, frets)  // ID m_Guitar etc,   "Guitar", # of strings, # of frets
{
 this.ID = id;
 this.InstrumentName = name;
 this.Strings = strings;         // number of strings
 this.Frets = frets;             // number of frets
 this.Tunings = new Array();     // tuning arrays
}

function Tuning(id, tuningName, arrMidiNotes)
{
 this.TuningID = id;
 this.TuningName = tuningName;
 this.TuningMidiNotes = arrMidiNotes;  // array of midi notes, starting with top string (low E on guitar)
}

function Note(iOffset, letter, sharpOrFlat) // offset int (c=0), letter string C, D, etc, sharpOrFlat string (#, b or "")
{
 var offset;

 if (iOffset > 11)
   offset = iOffset - 12;
 else 
   offset = iOffset;
   
 this.Offset = offset;           // 0 = C
 this.SharpFlat = sharpOrFlat;   // bb, b, "", #, or ##.  This routine will not produce either bbb or ###
 this.Letter = letter;           // C thru B
 switch(this.SharpFlat)          // set Text to the letter and proper # or b symbol
  { 
   case "bb": this.Text = letter + symFlat + symFlat;   this.SharpFlatOffset = -2; break; // -2 thru 2
   case "b":  this.Text = letter + symFlat;             this.SharpFlatOffset = -1; break;
   case "":   this.Text = letter;                       this.SharpFlatOffset = 0;  break;
   case "#":  this.Text = letter + symSharp;            this.SharpFlatOffset = 1;  break;
   case "##": this.Text = letter + symSharp + symSharp; this.SharpFlatOffset = 2;  break;
   default: throw new Error("function Note(offset, letter, sharpOrFlat) invalid sharpOrFlat value"); 
  }
 this.NextNote = function(step)  // object function that returns the next Note object in the current mode from this note based on the step
  {                              // this is used by the Key object to generate a list of notes in the key where the notes of the key always increment to the next letter
   var next;                     // so starting from the root each new note will be the next note letter in the series, eg D E F# G A B C#.  Sharps & Flats added as necessary.
   var nType; // 1=EF & BC          some modes end up with very wild sharp flat setups, check out gypsy minor results.

   if (step<1 || step>3)
     throw new Error("Note.NextNote(step) - step out of range"); // currently none of the modes have steps greater then 3
   switch(this.Letter)
    {
     case "C": next = "D"; nType = 2; break;  // this is fairly straight forward
     case "D": next = "E"; nType = 2; break;
     case "E": next = "F"; nType = 1; break;
     case "F": next = "G"; nType = 2; break;
     case "G": next = "A"; nType = 2; break;
     case "A": next = "B"; nType = 2; break;
     case "B": next = "C"; nType = 1; break;
     default: throw new Error("Note.NextNote(step) Invalid Note.Letter value");
    }
   if (nType == 2) // nType is the distance between note letters, E to F and B to C is 1, but all others is 2
    {
     switch(step)
      {
       case 1:
        {
         switch(this.SharpFlat)
          {
           case "bb": throw new Error("Dbbb?")                      // may need to enable this, not sure, problem is all these case statemments are coded for up to bb and ##
           case "b":  return new Note(this.Offset + 1, next, "bb"); // Cb to Dbb so nType = 2 (e.g. C to D), step = 1, so C has to go to D, C to D is 2 steps, so extra b is added 
           case "":   return new Note(this.Offset + 1, next, "b");  // C to Db, C natural + 1 is Db, fairly easy
           case "#":  return new Note(this.Offset + 1, next, "");   // C# to D, C# + 1 is a natural D
           case "##": return new Note(this.Offset + 1, next, "#");  // C## To D#, C##
           default: throw new Error("Note.NextNote(step) Invalid this.SharpFlat");  
          }
        } break;
       case 2:
        {
         switch(this.SharpFlat)
          {
           case "bb": return new Note(this.Offset + 2, next, "bb"); // Cbb to Dbb, step 2 if fairly simple, all the flats and sharps are carried over to the next note letter
           case "b":  return new Note(this.Offset + 2, next, "b");  // Cb to Db
           case "":   return new Note(this.Offset + 2, next, "");   // C to D
           case "#":  return new Note(this.Offset + 2, next, "#");  // C# to D
           case "##": return new Note(this.Offset + 2, next, "##"); // C## To D#
           default: throw new Error("Note.NextNote(step) Invalid this.SharpFlat value");
          }
        } break;
       case 3:
        {
         switch(this.SharpFlat)
          {
           case "bb": return new Note(this.Offset + 3, next, "bbb"); // Cbb to Dbbb, 3 steps is only found in Gypsy Minor
           case "b":  return new Note(this.Offset + 3, next, "bb");  // Cb to Dbb
           case "":   return new Note(this.Offset + 3, next, "b");   // C to Db
           case "#":  return new Note(this.Offset + 3, next, "");  // C# to D
           case "##": return new Note(this.Offset + 3, next, "#"); // C## To D#
           default: throw new Error("Note.NextNote(step) Invalid this.SharpFlat value");
          }
        } break;
      }
    }
   else 
    {
     switch(step)  // this handles going from E to F and B to C.  These notes are next to each other.
      {
       case 1: // 1 step to next note, this time we are working with E to F and B to C
        {
         switch(this.SharpFlat)
          {
           case "bb": return new Note(this.Offset + 1, next, "bb");  // Ebb to Fbb, so 1 step here is like 2 steps above, all sharps and flats carry over to C and F
           case "b":  return new Note(this.Offset + 1, next, "b");   // Eb to Fb
           case "":   return new Note(this.Offset + 1, next, "");    // E to F
           case "#": return new Note(this.Offset + 1,  next, "#");    // C## To D#
           case "##": return new Note(this.Offset + 1, next, "##");    // C## To D#
           default: throw new Error("Note.NextNote(step) Invalid this.SharpFlat value");
          }
        } break;
       case 2: // step == 2
        {
         switch(this.SharpFlat) // again, the next note always must be the next letter in the series regardless of step or the number of steps between the letters
          {
           case "bb": return new Note(this.Offset + 2, next, "b"); // Ebb to Fb, Ebb + 2 = Fb, going up 2, what F equivlent for Ebb + 2,  Ebb Eb E, what F = E, it's Fb   
           case "b":  return new Note(this.Offset + 2, next, "");  // Eb to F, up 2
           case "":   return new Note(this.Offset + 2, next, "#");   // E to F#
           case "#":  return new Note(this.Offset + 2, next, "##");  // E# to F##
           case "##": throw new Error("F### ?");                     // not going to do ###s or bbb's
           default: throw new Error("Note.NextNote(step) Invalid this.SharpFlat value");
          }
        } break;
       case 3: // step == 3
        {
         switch(this.SharpFlat)
          { 
           case "bb": return new Note(this.Offset + 2, next, "");  // Ebb to F
           case "b":  return new Note(this.Offset + 2, next, "#");  // Eb to F#
           case "":   return new Note(this.Offset + 2, next, "##");   // E to F##
           case "#":  return new Note(this.Offset + 2, next, "###");  // E# to F###
           case "##": throw new Error("F### ?");                     
           default: throw new Error("Note.NextNote(step) Invalid this.SharpFlat value");
          }
        } break;
      }
    } 
  };

} 

// chord pattern consists of a name and an array of pitches

function ChordPattern(id, strName, strAbbrev, arrPitches)
{
 this.ID = id;                           // unique id
 this.Name = strName;                    // Major, Minor
 this.ShortName = strAbbrev;             // symbols etc
 this.Pitches = arrPitches;              // array of steps, integers
 
 // Finger Placements, these arrays are imported from the c# program "GuitarChord", the .js is copied and pasted below quite a ways

 this.PatternGuitar = new Array();
 this.PatternBass = new Array();
 this.PatternMandolin = new Array();
 this.PatternUkulele = new Array();
 this.PatternKeyboard = new Array();

 this.Root="";
 this.Third="";
 this.Fifth="";
 this.Seventh="";
 this.Ninth="";

 switch(arrPitches[0])
  {
   case 0: this.Root="1";   break;
   case 1: this.Root="#1";  break;
   case 2: this.Root="##1"; break;
  }

 switch(arrPitches[1])
  {
   case 2: this.Third="bb3"; break;
   case 3: this.Third="b3";  break;
   case 4: this.Third="3";   break;
   case 5: this.Third="#3";  break;
   case 6: this.Third="##3"; break;
  }

 switch(arrPitches[2])
  {
   case 5: this.Fifth="bb5"; break;
   case 6: this.Fifth="b5";  break;
   case 7: this.Fifth="5";   break;
   case 8: this.Fifth="#5";  break;
   case 9: this.Fifth="##5"; break;
  }

 switch(arrPitches[3])
  {
   case 9: if (this.Name=="Dim 7th") this.Seventh="bb7"; else this.Seventh="6"; break;
   case 10: this.Seventh="b7";  break;
   case 11: this.Seventh="7";   break;
   case 12: this.Seventh="#7";  break;
   case 13: this.Seventh="##7"; break;
  }

 switch(arrPitches[4])
  {
   case 12: this.Ninth="bb9"; break;
   case 13: this.Ninth="b9";  break;
   case 14: this.Ninth="9";   break;
   case 15: this.Ninth="#9";  break;
   case 16: this.Ninth="##9"; break;
  }

 this.Formula=this.Root;
 
 if (this.Third != "")   this.Formula+="-"+this.Third;
 if (this.Fifth != "")   this.Formula+="-"+this.Fifth;
 if (this.Seventh != "") this.Formula+="-"+this.Seventh;
 if (this.Ninth != "")   this.Formula+="-"+this.Ninth;

}

// Fingering

function Fingering(str, fret)
{
 this.Str = str;    // string number, top string is 0 (low E on guitar)
 this.Fret = fret;  // fret number
}

// Fingering for the barre chord index finger

function BarreIndex(str, fret, showNote)
{
 this.Str = str;
 this.Fret = fret;
 this.ShowNote = showNote;  // 1, show the note, it's part of the cord, 0, don't show the note, just show the "I"
}

// placements, chord fingerings

function Placement(id, instrument, offset, arrIndex, arrMiddle, arrRing, arrPinky, arrOpen, arrNoPlay)
{
 this.ID = id;
 this.Instrument = instrument;  // m_Guitar etc
 this.Offset = offset;          // C = 0
 this.Index = arrIndex;         // list of Fingering
 this.Middle = arrMiddle;
 this.Ring = arrRing;
 this.Pinky = arrPinky;
 this.Open = arrOpen;
 this.NoPlay = arrNoPlay;
}

// C C#/Db D D#/Eb E  F  F#/Gb G G#/Ab A A#/Bb B/Cb
// 0   1   2   3   4  5    6   7   8   9  10    11

// E and A Barre pattern placement

function BarrePlacement(id, offset, chordPattern, instrument, arrIndex, arrMiddle, arrRing, arrPinky, arrNoPlay)
{
 var i, k, fa;

 this.ID = id;                  // unique id
 this.Offset = offset;          // c=0
 this.CP = chordPattern;        // m_cpMajor = 0
 this.Instrument = instrument;  // m_Guitar etc
 switch(offset)
  {
   case 9: // is it the A pattern?
     this.Offsets = [2,3,4,5,6,7,8,9,10,11,0,1,2,3];   // Bb B C Db D -  steps to take to wrap around to C.  14 entries, how far the barre's can go up the fretboard
     break;
   case 4: // E
     this.Offsets = [7,8,9,10,11,0,1,2,3,4,5,6,7,8];   // F Gb G Ab A Bb B C, used to locate position on fretboard for the barre
     break;
   case 2: // D
     this.Offsets = [9,10,11,0,1,2,3,4,5,6,7,8,9,10];   // Eb E F Gb G Ab A Bb B C, used to locate position on fretboard for the barre
     break;
  }
 this.Index = new Array();  // store finger positions for each barre chord starting with 1st barre above  Bb for the A pattern, F for the E pattern
 this.Middle = new Array();
 this.Ring = new Array();
 this.Pinky = new Array();
 this.NoPlay = new Array(); // no open strings

 // Fingering objects are a bit different than the above placements
 // Index Fingering.Fret = 0  and all others are # of frets past the Index 
 // so the barre chord can moved about on the fretboard

for (i=1; i<14; i++)  // starting with Bb for the A pattern and F for the E pattern, they are stored in the array at index 0
  {
   fa = new Array();
   for (k=0; k<arrIndex.length; k++)
     fa[k]= new BarreIndex(arrIndex[k].Str, arrIndex[k].Fret + i, arrIndex[k].ShowNote);
   this.Index[i-1] = fa;
  }
 for (i=1; i<14; i++)
  {
   fa = new Array();
   for (k=0; k<arrMiddle.length; k++)
     fa[k]= new Fingering(arrMiddle[k].Str, arrMiddle[k].Fret + i);
   this.Middle[i-1] = fa;
  }
 for (i=1; i<14; i++)
  {
   fa = new Array();
   for (k=0; k<arrRing.length; k++)
     fa[k]= new Fingering(arrRing[k].Str, arrRing[k].Fret + i);
   this.Ring[i-1] = fa;
  }
 for (i=1; i<14; i++)
  {
   fa = new Array();
   for (k=0; k<arrPinky.length; k++)
     fa[k]= new Fingering(arrPinky[k].Str, arrPinky[k].Fret + i);
   this.Pinky[i-1] = fa;
  }
 for (i=1; i<14; i++)
  {
   fa = new Array();
   for (k=0; k<arrNoPlay.length; k++)
     fa[k]= new Fingering(arrNoPlay[k].Str, arrNoPlay[k].Fret + i);
   this.NoPlay[i-1] = fa;
  }
}

// a midi note consists of the midi number, offset distance from "C", the octive, and frequency

function MidiNote(id, nMidi, nOffset, nOctive, fFreq)
{
 this.ID = id;             // unique id
 this.Number = nMidi;      // midi note C4 = 60
 this.Offset = nOffset;    // C = 0
 this.Octave = nOctive;    // 4 is middle C
 this.Frequency = fFreq;   // in hertz
 this.MidiName = "";       // midi name contains octive D#6/Eb6
 this.Name = function(key) // name does not contain octive numbers
  {
   var note;
   
   note = key.OffsetNote(this.Offset);
   if (note == null)
     return NoteText(this.Offset);
   else 
     return note.Text; 
  };   
 this.MidiName = function(key) 
  {
   var note;

   note = key.OffsetNote(this.Offset);
   if (note == null)
     return NoteText(this.Offset) + "(" + this.Octave.toString() + ")";
   else
     return note.Text + this.Octave.toString(); 
  };
}

// modes: ionian, dorian etc

function Mode(nNdx, sBGColor, sName, arrPitches, arrChordType, arrKeyList) 
{
 this.ID=nNdx;                // unique id
 this.ModeName=sName;         // ionian, dorian etc
 this.Sequences=arrPitches;   // list of steps, pitches between chords, Major is 2,2,1,2,2,2,1
 this.ChordType=arrChordType; // list of chord types for each chord in the mode, Major is m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor,cDim
 this.Background=sBGColor;    // background color in the combo box drop down
 this.KeyList = arrKeyList;   // Array of key "Note" objects to display for the mode
}

// key signature

function Key(mode, startNote) // mode index, starting Note object
{
 var os, i, found, k;

 this.Offset = startNote.Offset;  // c = 0
 this.Mode = mode;
 this.Notes = new Array();        // list of note names with special characters for sharps and flats
 this.Offsets = new Array();      // offset notes of the key
 this.LookUp = new Array();       // a way to find the note name in the key only knowing what the offset is C = 0
 this.OffsetNote = function(offset) // return Note object
  {
   if (this.LookUp[offset] >=0)
     return this.Notes[this.LookUp[offset]];
   else
    {
     return null;
    }
  };

 os = startNote.Offset;       // get the key's starting note offset, c = 0
 this.Offsets[0] = os;
 this.Notes[0] = startNote;   // add the 1st note of the key
 for (i=1; i<7; i++)          // add the next 6 notes of key, start with 1
  {
   this.Notes[i] = this.Notes[i-1].NextNote(m_arrModes[mode].Sequences[i-1]); // populate the Notes array
   os += m_arrModes[mode].Sequences[i-1];   // move to the next offset based on the current mode's pitch sequence
   if (os >= 12)        // if offset > 12 
     os -= 12;          // wrap it back around to 0
   this.Offsets[i] = os; // populate the Offsets array
  }

 for (i=0; i<12; i++) // build a list of all 12 offsets with the appropriate index of notes in this key, entries of offsets of notes not in this key will be -1 
  {
   found = false;
   for (k=0; k<this.Offsets.length; k++) 
    {
     if (i == this.Offsets[k])
      {
       this.LookUp.push(k);  // save the index to the this.Notes array
       found = true;
      }
    }
   if (found == false)
     this.LookUp.push(-1); // offset of note is not in this key
  }
}

//////////////////////////////////
//   Array Building Functions
//////////////////////////////////

function makeInstruments()
{
 m_arrInstruments[m_Guitar] = new Instrument(m_Guitar, "Guitar", 6, 24); // 6 strings 24 frets
 m_arrInstruments[m_Guitar].Tunings[0] =  new Tuning(0, "Standard Tuning", [40, 45, 50, 55, 59, 64]); // E2 A2 D3 G3 B3 E4  midi notes
 m_arrInstruments[m_Guitar].Tunings[1] =  new Tuning(1, "Half-Step Down", [39, 44, 49, 54, 58, 63]);
 m_arrInstruments[m_Guitar].Tunings[2] =  new Tuning(2, "Full-Step Down", [38, 43, 48, 53, 57, 62]);
 m_arrInstruments[m_Guitar].Tunings[3] =  new Tuning(3, "Drop-D", [38, 45, 50, 55, 59, 64]);
 m_arrInstruments[m_Guitar].Tunings[4] =  new Tuning(4, "Double-D", [38, 45, 50, 55, 59, 62]);
 m_arrInstruments[m_Guitar].Tunings[5] =  new Tuning(5, "D-Suspended (Modal)", [38, 45, 50, 55, 57, 62]);
 m_arrInstruments[m_Guitar].Tunings[6] =  new Tuning(6, "Open-D (Fingerstyle)", [38, 45, 50, 54, 57, 62]);
 m_arrInstruments[m_Guitar].Tunings[7] =  new Tuning(7, "Open-C (Fingerstyle)", [36, 43, 48, 55, 60, 64]);
 m_arrInstruments[m_Guitar].Tunings[8] =  new Tuning(8, "Open-G (Slide)", [38, 43, 50, 55, 59, 62]);
 m_arrInstruments[m_Guitar].Tunings[9] =  new Tuning(9, "Open-E (Blues)", [40, 47, 52, 56, 59, 64]);
 m_arrInstruments[m_Guitar].Tunings[10] = new Tuning(10,"Open-D (Minor)", [38, 45, 50, 53, 57, 62]);
 m_arrInstruments[m_Guitar].Tunings[11] = new Tuning(11,"Open-G (Minor)", [38, 43, 50, 55, 58, 62]);

 m_arrInstruments[m_Bass] = new Instrument(m_Bass, "Bass Guitar", 4, 24);
 m_arrInstruments[m_Bass].Tunings[0] =  new Tuning(0, "Standard Tuning", [28, 33, 38, 43]);  // E1 A1 D2 G2
 m_arrInstruments[m_Bass].Tunings[1] =  new Tuning(1, "Half-Step Down", [27, 32, 37, 42]);
 m_arrInstruments[m_Bass].Tunings[2] =  new Tuning(2, "Full-Step Down", [26, 31, 36, 41]);
 m_arrInstruments[m_Bass].Tunings[3] =  new Tuning(3, "Fifths (Extended Range)", [24, 31, 38, 45]);
 m_arrInstruments[m_Bass].Tunings[4] =  new Tuning(4, "Drop-D", [26, 33, 38, 43]);
 m_arrInstruments[m_Bass].Tunings[5] =  new Tuning(5, "Drop-C", [24, 33, 38, 43]);
 m_arrInstruments[m_Bass].Tunings[6] =  new Tuning(6, "Big Bottom", [24, 31, 36, 41]);
 m_arrInstruments[m_Bass].Tunings[7] =  new Tuning(7, "Drop-B", [23, 30, 35, 40]);
 m_arrInstruments[m_Bass].Tunings[1] =  new Tuning(8, "Low-B", [23, 28, 33, 38]);

 m_arrInstruments[m_Mandolin] = new Instrument(m_Mandolin, "Mandolin", 4, 17);
 m_arrInstruments[m_Mandolin].Tunings[0] =  new Tuning(0, "Standard Tuning", [55, 62, 69, 76]); // G3  D4  A4  E5
 m_arrInstruments[m_Mandolin].Tunings[1] =  new Tuning(1, "Half-Step Down", [54, 61, 68, 75]);  // Gb Db Ab Eb
 m_arrInstruments[m_Mandolin].Tunings[2] =  new Tuning(2, "Full-Step Down", [53, 60, 67, 74]);  // F  C  G  D
 m_arrInstruments[m_Mandolin].Tunings[3] =  new Tuning(3, "Drop-D", [55, 62, 69, 74]);          // G  D  A  D
 m_arrInstruments[m_Mandolin].Tunings[4] =  new Tuning(4, "D (Modal)", [62, 67, 69, 74]);       // G  D  A  D
 m_arrInstruments[m_Mandolin].Tunings[5] =  new Tuning(5, "Fourths", [50, 55, 60, 65]);         // D  G  C  F 
 m_arrInstruments[m_Mandolin].Tunings[6] =  new Tuning(6, "Open-D", [57, 62, 66, 74]);          // A  D  Gb D
 m_arrInstruments[m_Mandolin].Tunings[7] =  new Tuning(7, "Open-E", [56, 64, 67, 76]);          // G# E  B  E        
 m_arrInstruments[m_Mandolin].Tunings[8] =  new Tuning(8, "Open-G", [55, 62, 71, 74]);          // G  D  B  D  

 m_arrInstruments[m_Ukulele] = new Instrument(m_Ukulele, "Ukulele", 4, 20);
 m_arrInstruments[m_Ukulele].Tunings[0] =  new Tuning(0, "Standard Tuning", [55, 62, 69, 76]); // G D A E

 m_arrInstruments[m_Keyboard] = new Instrument(m_Keyboard, "Keyboard", 24, 1);

 var piano = new Array();
 for (i=0;i<m_arrInstruments[m_Keyboard].Frets; i++)
   piano.push(60 + i) // C4

 m_arrInstruments[m_Keyboard].Tunings[0] =  new Tuning("Keyboard", piano);
}


// make the chord patterns

function makeChordPatterns()
{
 m_arrChordPatterns[m_cpMajor]  = new ChordPattern(m_cpMajor,   "Major",        symMajor,     [0,4,7]);
 m_arrChordPatterns[m_cpMinor]  = new ChordPattern(m_cpMinor,   "Minor",        "m",          [0,3,7]);
 m_arrChordPatterns[m_cpSus]    = new ChordPattern(m_cpSus,     "Sus4",         "sus4",       [0,5,7]);
 m_arrChordPatterns[m_cpAug]    = new ChordPattern(m_cpAug,     "Aug+",         "+",          [0,4,8]);
 m_arrChordPatterns[m_cpDim]    = new ChordPattern(m_cpDim,     "Dim",          symFDim,      [0,3,6]);
 m_arrChordPatterns[m_cpMajor6] = new ChordPattern(m_cpMajor6,  "Major 6th",    symMajor+"6", [0,4,7,9]); // 1-3-5-6
 m_arrChordPatterns[m_cpMinor6] = new ChordPattern(m_cpMinor6,  "Minor 6th",    "m6",         [0,3,7,9]); // 1-b3-5-6
 m_arrChordPatterns[m_cpMajor7] = new ChordPattern(m_cpMajor7,  "Major 7th",    symMajor+"7", [0,4,7,11]); 
 m_arrChordPatterns[m_cpMinor7] = new ChordPattern(m_cpMinor7,  "Minor 7th",    "m7",         [0,3,7,10]); // oops, thought it was 11
 m_arrChordPatterns[m_cpDom7]   = new ChordPattern(m_cpDom7,    "Dom 7th",      "7",          [0,4,7,10]);
 m_arrChordPatterns[m_cpHalfDim7]  = new ChordPattern(m_cpHalfDim7,"Half Dim 7th", symDim7+"7", [0,3,6,10]);
 m_arrChordPatterns[m_cpDim7]   = new ChordPattern(m_cpDim7,    "Dim 7th",      symFDim+"7",  [0,3,6,9]);
 m_arrChordPatterns[m_cpMajor9] = new ChordPattern(m_cpMajor9,  "Major 9th",    symMajor+"9", [0,4,7,11,14]);
 m_arrChordPatterns[m_cpMinor9] = new ChordPattern(m_cpMinor9,  "Minor 9th",    "m9",         [0,3,7,10,14]);
 m_arrChordPatterns[m_cpDom9]   = new ChordPattern(m_cpDom9,    "Dom 9th",      "9",          [0,4,7,10,14]);
}

// make all the midi notes, using the "Roland" naming standard
// MidiNote arguments are id #, midi note #, "C" offset, the octave, frequency in hertz
// requires that makeNotes is called first

function makeMidiNotes()
{
 var i,k;

 m_arrMidiNotesHL[0] = new  MidiNote(0, 127,	7, 9, 12543.85);
 m_arrMidiNotesHL[1] = new MidiNote(1, 126, 6, 9, 11839.82);
 m_arrMidiNotesHL[2] = new MidiNote(2, 125, 5, 9,	11175.30);
 m_arrMidiNotesHL[3] = new MidiNote(3, 124, 4, 9, 10548.08);
 m_arrMidiNotesHL[4] = new MidiNote(4, 123, 3, 9, 9956.06);
 m_arrMidiNotesHL[5] = new MidiNote(5, 122, 2, 9,	9397.27);
 m_arrMidiNotesHL[6] = new MidiNote(6, 121, 1, 9, 8869.84);
 m_arrMidiNotesHL[7] = new MidiNote(7, 120, 0, 9, 8372.02);
 m_arrMidiNotesHL[8] = new MidiNote(8, 119, 11, 8, 7902.13);
 m_arrMidiNotesHL[9] = new MidiNote(9, 118, 10, 8, 7458.62);
 m_arrMidiNotesHL[10] = new MidiNote(10, 117, 9, 8,7040.00);
 m_arrMidiNotesHL[11] = new MidiNote(11, 116, 8, 8, 6644.88);
 m_arrMidiNotesHL[12] = new MidiNote(12, 115, 7, 8,	6271.93);
 m_arrMidiNotesHL[13] = new MidiNote(13, 114, 6, 8,	5919.91);
 m_arrMidiNotesHL[14] = new MidiNote(14, 113, 5, 8,	5587.65);
 m_arrMidiNotesHL[15] = new MidiNote(15, 112, 4, 8,	5274.04);
 m_arrMidiNotesHL[16] = new MidiNote(16, 111, 3, 8,	4978.03);
 m_arrMidiNotesHL[17] = new MidiNote(17, 110, 2, 8,	4698.64);
 m_arrMidiNotesHL[18] = new MidiNote(18, 109, 1, 8,	4434.92);
 m_arrMidiNotesHL[19] = new MidiNote(19, 108, 0, 8,	4186.01);
 m_arrMidiNotesHL[20] = new MidiNote(20, 107, 11, 7, 3951.07);
 m_arrMidiNotesHL[21] = new MidiNote(21, 106, 10, 7, 3729.31);
 m_arrMidiNotesHL[22] = new MidiNote(22, 105, 9, 7, 3520.00);
 m_arrMidiNotesHL[23] = new MidiNote(23, 104, 8, 7, 3322.44);
 m_arrMidiNotesHL[24] = new MidiNote(24, 103, 7, 7,	3135.96);
 m_arrMidiNotesHL[25] = new MidiNote(25, 102, 6, 7,	2959.96);
 m_arrMidiNotesHL[26] = new MidiNote(26, 101, 5, 7,	2793.83);
 m_arrMidiNotesHL[27] = new MidiNote(27, 100, 4, 7,	2637.02);
 m_arrMidiNotesHL[28] = new MidiNote(28, 99,	3, 7, 2489.02);
 m_arrMidiNotesHL[29] = new MidiNote(29, 98,	2, 7, 2349.32);
 m_arrMidiNotesHL[30] = new MidiNote(30, 97,	1, 7, 2217.46);
 m_arrMidiNotesHL[31] = new MidiNote(31, 96,	0, 7,	2093.00);
 m_arrMidiNotesHL[32] = new MidiNote(32, 95, 11, 6,	1975.53);
 m_arrMidiNotesHL[33] = new MidiNote(33, 94, 10, 6,	1864.66);
 m_arrMidiNotesHL[34] = new MidiNote(34, 93, 9, 6, 1760.00);
 m_arrMidiNotesHL[35] = new MidiNote(35, 92, 8, 6, 1661.22);
 m_arrMidiNotesHL[36] = new MidiNote(36, 91, 7, 6, 1567.98);
 m_arrMidiNotesHL[37] = new MidiNote(37, 90, 6, 6, 1479.98);
 m_arrMidiNotesHL[38] = new MidiNote(38, 89, 5, 6, 1396.91);
 m_arrMidiNotesHL[39] = new MidiNote(39, 88, 4, 6, 1318.51);
 m_arrMidiNotesHL[40] = new MidiNote(40, 87, 3, 6, 1244.51);
 m_arrMidiNotesHL[41] = new MidiNote(41, 86, 2, 6, 1174.66);
 m_arrMidiNotesHL[42] = new MidiNote(42, 85, 1, 6, 1108.73);
 m_arrMidiNotesHL[43] = new MidiNote(43, 84, 0,	6, 1046.50);
 m_arrMidiNotesHL[44] = new MidiNote(44, 83, 11, 5, 987.77);
 m_arrMidiNotesHL[45] = new MidiNote(45, 82, 10, 5,	932.33);
 m_arrMidiNotesHL[46] = new MidiNote(46, 81, 9, 5, 880.00);
 m_arrMidiNotesHL[47] = new MidiNote(47, 80, 8, 5, 830.61);
 m_arrMidiNotesHL[48] = new MidiNote(48, 79, 7, 5, 783.99);
 m_arrMidiNotesHL[49] = new MidiNote(49, 78, 6, 5, 739.99);
 m_arrMidiNotesHL[50] = new MidiNote(50, 77, 5, 5, 698.46);
 m_arrMidiNotesHL[51] = new MidiNote(51, 76, 4, 5, 659.26);
 m_arrMidiNotesHL[52] = new MidiNote(52, 75, 3, 5, 622.25);
 m_arrMidiNotesHL[53] = new MidiNote(53, 74, 2, 5, 587.33);
 m_arrMidiNotesHL[54] = new MidiNote(54, 73, 1, 5, 554.37);
 m_arrMidiNotesHL[55] = new MidiNote(55, 72, 0, 5, 523.25);
 m_arrMidiNotesHL[56] = new MidiNote(56, 71, 11, 4, 493.88);
 m_arrMidiNotesHL[57] = new MidiNote(57, 70, 10, 4, 466.16);
 m_arrMidiNotesHL[58] = new MidiNote(58, 69, 9, 4, 440.00);
 m_arrMidiNotesHL[59] = new MidiNote(59, 68, 8, 4, 415.30);
 m_arrMidiNotesHL[60] = new MidiNote(60, 67, 7, 4, 392.00); 
 m_arrMidiNotesHL[61] = new MidiNote(61, 66, 6, 4, 369.99);
 m_arrMidiNotesHL[62] = new MidiNote(62, 65, 5, 4, 349.23);
 m_arrMidiNotesHL[63] = new MidiNote(63, 64, 4, 4, 329.63);
 m_arrMidiNotesHL[64] = new MidiNote(64, 63, 3, 4, 311.13);
 m_arrMidiNotesHL[65] = new MidiNote(65, 62, 2, 4, 293.66);
 m_arrMidiNotesHL[66] = new MidiNote(66, 61, 1, 4, 277.18);
 m_arrMidiNotesHL[67] = new MidiNote(67, 60, 0, 4, 261.63);   // middle C4
 m_arrMidiNotesHL[68] = new MidiNote(68, 59, 11, 3, 246.94);
 m_arrMidiNotesHL[69] = new MidiNote(69, 58, 10, 3, 233.08);
 m_arrMidiNotesHL[70] = new MidiNote(70, 57, 9, 3, 220.00);
 m_arrMidiNotesHL[71] = new MidiNote(71, 56, 8, 3, 207.65);
 m_arrMidiNotesHL[72] = new MidiNote(72, 55, 7, 3, 196.00);
 m_arrMidiNotesHL[73] = new MidiNote(73, 54, 6, 3, 185.00);
 m_arrMidiNotesHL[74] = new MidiNote(74, 53, 5, 3, 174.61);
 m_arrMidiNotesHL[75] = new MidiNote(75, 52, 4, 3, 164.81);
 m_arrMidiNotesHL[76] = new MidiNote(76, 51, 3, 3, 155.56);
 m_arrMidiNotesHL[77] = new MidiNote(77, 50, 2, 3, 146.83);
 m_arrMidiNotesHL[78] = new MidiNote(78, 49, 1, 3, 138.59);
 m_arrMidiNotesHL[79] = new MidiNote(79, 48, 0, 3, 130.81);
 m_arrMidiNotesHL[80] = new MidiNote(80, 47, 11, 2, 123.47);
 m_arrMidiNotesHL[81] = new MidiNote(81, 46, 10, 2, 116.54);
 m_arrMidiNotesHL[82] = new MidiNote(82, 45, 9, 2, 110.00);
 m_arrMidiNotesHL[83] = new MidiNote(83, 44, 8, 2, 103.83);
 m_arrMidiNotesHL[84] = new MidiNote(84, 43, 7, 2, 98.00);
 m_arrMidiNotesHL[85] = new MidiNote(85, 42, 6, 2, 92.50);
 m_arrMidiNotesHL[86] = new MidiNote(86, 41, 5, 2, 87.31);
 m_arrMidiNotesHL[87] = new MidiNote(87, 40, 4, 2, 82.41);
 m_arrMidiNotesHL[88] = new MidiNote(88, 39, 3, 2, 77.78);
 m_arrMidiNotesHL[89] = new MidiNote(89, 38, 2, 2, 73.42);
 m_arrMidiNotesHL[90] = new MidiNote(90, 37, 1, 2, 69.30);
 m_arrMidiNotesHL[91] = new MidiNote(91, 36, 0, 2, 65.41);
 m_arrMidiNotesHL[92] = new MidiNote(92, 35, 11, 1, 61.74);
 m_arrMidiNotesHL[93] = new MidiNote(93, 34, 10, 1, 58.27);
 m_arrMidiNotesHL[94] = new MidiNote(94, 33, 9, 1, 55.00);
 m_arrMidiNotesHL[95] = new MidiNote(95, 32, 8, 1, 51.91);
 m_arrMidiNotesHL[96] = new MidiNote(96, 31, 7, 1, 49.00);
 m_arrMidiNotesHL[97] = new MidiNote(97, 30, 6, 1, 46.25);
 m_arrMidiNotesHL[98] = new MidiNote(98, 29, 5, 1, 43.65);
 m_arrMidiNotesHL[99] = new MidiNote(99, 28, 4, 1, 41.20);
 m_arrMidiNotesHL[100] = new MidiNote(100, 27, 3, 1, 38.89);
 m_arrMidiNotesHL[101] = new MidiNote(101, 26, 2, 1, 36.71);
 m_arrMidiNotesHL[102] = new MidiNote(102, 25, 1, 1, 34.65);
 m_arrMidiNotesHL[103] = new MidiNote(103, 24, 0, 1, 32.70);
 m_arrMidiNotesHL[104] = new MidiNote(104, 23, 11, 0, 30.87);
 m_arrMidiNotesHL[105] = new MidiNote(105, 22, 10, 0, 29.14);
 m_arrMidiNotesHL[106] = new MidiNote(106, 21, 9, 0, 27.50);

 // copy notes to LH array in reverse order

 k = 106;
 for (i = 0; i<107; i++)
  {
   m_arrMidiNotesLH[i] = m_arrMidiNotesHL[k];
   m_mapMidiNotes.set(m_arrMidiNotesHL[k].Number, m_arrMidiNotesHL[k]); // this map is used to look up the Midi object given a midi note number
   k--;
  }
}

// C C#/Db D D#/Eb E  F  F#/Gb G G#/Ab A A#/Bb B/Cb
// 0   1   2   3   4  5    6   7   8   9  10    11

// Modes

function makeModes()
{
 m_arrModes[0]=new Mode(0,"#7BBDFF","Ionian (Major)",[2,2,1,2,2,2,1],[m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor,m_cpDim], [new Note(0,"C",""),new Note(7,"G",""),new Note(2,"D",""),new Note(9,"A",""),new Note(4,"E",""),new Note(11, "B",""),new Note(6,"F","#"),new Note(1,"C","#"),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b"),new Note(1,"D","b"),new Note(6,"G","b"),new Note(11,"C","b")]);
 
 m_arrModes[1]=new Mode(1,"#7BBDFF","Dorian",[2,1,2,2,2,1,2],[m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor,m_cpDim,m_cpMajor],[new Note(9,"A",""),new Note(4,"E",""),new Note(11,"B",""),new Note(5,"F","#"),new Note(1,"C","#"),new Note(8, "G","#"),new Note(3,"D","#"),new Note(10,"A","#"),new Note(2,"D",""),new Note(7,"G",""),new Note(0,"C",""),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b")]);
 m_arrModes[2]=new Mode(2,"#7BBDFF","Phrygian",[1,2,2,2,1,2,2],[m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor],[new Note(9,"A",""),new Note(4,"E",""),new Note(11,"B",""),new Note(5,"F","#"),new Note(1,"C","#"),new Note(8, "G","#"),new Note(3,"D","#"),new Note(10,"A","#"),new Note(2,"D",""),new Note(7,"G",""),new Note(0,"C",""),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b")]);
 m_arrModes[3]=new Mode(3,"#7BBDFF","Lydian",[2,2,2,1,2,2,1], [m_cpMajor,m_cpMajor,m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor],[new Note(0,"C",""),new Note(7,"G",""),new Note(2,"D",""),new Note(9,"A",""),new Note(4,"E",""),new Note(11, "B",""),new Note(6,"F","#"),new Note(1,"C","#"),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b"),new Note(1,"D","b"),new Note(6,"G","b"),new Note(11,"C","b")]);
 m_arrModes[4]=new Mode(4,"#7BBDFF","Mixolydian",[2,2,1,2,2,1,2], [m_cpMajor,m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor],[new Note(0,"C",""),new Note(7,"G",""),new Note(2,"D",""),new Note(9,"A",""),new Note(4,"E",""),new Note(11, "B",""),new Note(6,"F","#"),new Note(1,"C","#"),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b"),new Note(1,"D","b"),new Note(6,"G","b"),new Note(11,"C","b")]);
 m_arrModes[5]=new Mode(5,"#7BBDFF","Aeolian (Minor)",[2,1,2,2,1,2,2], [m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor],[new Note(9,"A",""),new Note(4,"E",""),new Note(11,"B",""),new Note(5,"F","#"),new Note(1,"C","#"),new Note(8, "G","#"),new Note(3,"D","#"),new Note(10,"A","#"),new Note(2,"D",""),new Note(7,"G",""),new Note(0,"C",""),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b")]);
 m_arrModes[6]=new Mode(6,"#7BBDFF","Locrian",[1,2,2,1,2,2,2], [m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor],[]);

 m_arrModes[7]=new Mode(7,"#7BFFBD","Major 7th",[2,2,1,2,2,2,1], [m_cpMajor7,m_cpMinor7,m_cpMinor7,m_cpMajor7,m_cpDom7,m_cpMinor7,m_cpHalfDim7],[new Note(0,"C",""),new Note(7,"G",""),new Note(2,"D",""),new Note(9,"A",""),new Note(4,"E",""),new Note(11, "B",""),new Note(6,"F","#"),new Note(1,"C","#"),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b"),new Note(1,"D","b"),new Note(6,"G","b"),new Note(11,"C","b")]);
 m_arrModes[8]=new Mode(8,"#7BFFBD","Minor 7th",[2,1,2,2,1,2,2], [m_cpMinor7,m_cpHalfDim7,m_cpMajor7,m_cpMinor7,m_cpMinor7,m_cpMajor7,m_cpDom7],[new Note(9,"A",""),new Note(4,"E",""),new Note(11,"B",""),new Note(5,"F","#"),new Note(1,"C","#"),new Note(8, "G","#"),new Note(3,"D","#"),new Note(10,"A","#"),new Note(2,"D",""),new Note(7,"G",""),new Note(0,"C",""),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b")]);

 m_arrModes[9]=new Mode(9,"#FFFF7B","Harmonic Major",[2,2,1,2,2,3,1], [m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor,m_cpDim],[new Note(0,"C",""),new Note(7,"G",""),new Note(2,"D",""),new Note(9,"A",""),new Note(4,"E",""),new Note(11, "B",""),new Note(6,"F","#"),new Note(1,"C","#"),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b"),new Note(1,"D","b"),new Note(6,"G","b"),new Note(11,"C","b")]);
 m_arrModes[10]=new Mode(10,"#FFFF7B","Harmonic Minor",[2,1,2,2,1,3,1], [m_cpMinor,m_cpDim,m_cpAug,m_cpMinor,m_cpMajor,m_cpMajor,m_cpDim],[new Note(9,"A",""),new Note(4,"E",""),new Note(11,"B",""),new Note(5,"F","#"),new Note(1,"C","#"),new Note(8, "G","#"),new Note(3,"D","#"),new Note(10,"A","#"),new Note(2,"D",""),new Note(7,"G",""),new Note(0,"C",""),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b")]);
 m_arrModes[11]=new Mode(11,"#FFFF7B","Melodic Minor (ascending)",[2,1,2,2,2,2,1], [m_cpMinor,m_cpMinor,m_cpAug,m_cpMajor,m_cpMajor,m_cpDim,m_cpDim],[new Note(9,"A",""),new Note(4,"E",""),new Note(11,"B",""),new Note(5,"F","#"),new Note(1,"C","#"),new Note(8, "G","#"),new Note(3,"D","#"),new Note(10,"A","#"),new Note(2,"D",""),new Note(7,"G",""),new Note(0,"C",""),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b")]);
 m_arrModes[12]=new Mode(12,"#FFFF7B","Gypsy Minor",[2,1,3,1,1,2,2], [m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor],[new Note(9,"A",""),new Note(4,"E",""),new Note(11,"B",""),new Note(5,"F","#"),new Note(1,"C","#"),new Note(8, "G","#"),new Note(3,"D","#"),new Note(10,"A","#"),new Note(2,"D",""),new Note(7,"G",""),new Note(0,"C",""),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b")]);
 m_arrModes[13]=new Mode(13,"#FFFF7B","Hungarian Minor",[2,1,3,1,1,3,1], [m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor],[new Note(9,"A",""),new Note(4,"E",""),new Note(11,"B",""),new Note(5,"F","#"),new Note(1,"C","#"),new Note(8, "G","#"),new Note(3,"D","#"),new Note(10,"A","#"),new Note(2,"D",""),new Note(7,"G",""),new Note(0,"C",""),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b")]);
 m_arrModes[14]=new Mode(14,"#FFFF7B","Persian Minor",[1,3,1,1,2,3,1], [m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor],[new Note(9,"A",""),new Note(4,"E",""),new Note(11,"B",""),new Note(5,"F","#"),new Note(1,"C","#"),new Note(8, "G","#"),new Note(3,"D","#"),new Note(10,"A","#"),new Note(2,"D",""),new Note(7,"G",""),new Note(0,"C",""),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b")]);
 m_arrModes[15]=new Mode(15,"#FFFF7B","Spanish Minor",[1,3,1,2,1,2,2], [m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor],[new Note(9,"A",""),new Note(4,"E",""),new Note(11,"B",""),new Note(5,"F","#"),new Note(1,"C","#"),new Note(8, "G","#"),new Note(3,"D","#"),new Note(10,"A","#"),new Note(2,"D",""),new Note(7,"G",""),new Note(0,"C",""),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b")]);

 m_arrModes[16]=new Mode(16,"#FFB8FF","Altered Dominant",[1,2,1,2,2,2,2], [m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor,m_cpMinor],[]);
 m_arrModes[17]=new Mode(17,"#FFB8FF","Overtone Dominant",[2,2,2,1,2,1,2], [m_cpMajor,m_cpMajor,m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor],[new Note(0,"C",""),new Note(7,"G",""),new Note(2,"D",""),new Note(9,"A",""),new Note(4,"E",""),new Note(11, "B",""),new Note(6,"F","#"),new Note(1,"C","#"),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b"),new Note(1,"D","b"),new Note(6,"G","b"),new Note(11,"C","b")]);
 m_arrModes[18]=new Mode(18,"#FFB8FF","Augmented Whole Tone",[2,2,2,2,2,2,2], [m_cpMinor,m_cpDim,m_cpMajor,m_cpMinor,m_cpMinor,m_cpMajor,m_cpMajor],[new Note(9,"A",""),new Note(4,"E",""),new Note(11,"B",""),new Note(5,"F","#"),new Note(1,"C","#"),new Note(8, "G","#"),new Note(3,"D","#"),new Note(10,"A","#"),new Note(2,"D",""),new Note(7,"G",""),new Note(0,"C",""),new Note(5,"F",""),new Note(10,"B","b"),new Note(3,"E","b"),new Note(8,"A","b")]);
}

// C C#/Db D D#/Eb E  F  F#/Gb G G#/Ab A A#/Bb B/Cb
// 0   1   2   3   4  5    6   7   8   9  10    11

// makeChordPatternPlacements generated by GuitarChord program at 2/17/2023 5:15:52 PM

function makeChordPatternPlacements()
{
 m_arrChordPatterns[m_cpMajor].PatternGuitar[0] = new Placement(1, m_Guitar, 0, [new Fingering(4, 1)], [new Fingering(2, 2)], [new Fingering(1, 3)], new Array(), [new Fingering(3, 0), new Fingering(5, 0)], [new Fingering(0, 0)], );
 m_arrChordPatterns[m_cpMajor].PatternGuitar[1] = new Placement(2, m_Guitar, 2, [new Fingering(3, 2)], [new Fingering(5, 2)], [new Fingering(4, 3)], new Array(), [new Fingering(2, 0)], [new Fingering(0, 0), new Fingering(1, 0)], );
 m_arrChordPatterns[m_cpMajor].PatternGuitar[2] = new Placement(3, m_Guitar, 4, new Array(), [new Fingering(3, 1)], [new Fingering(1, 2)], [new Fingering(2, 2)], [new Fingering(0, 0), new Fingering(4, 0), new Fingering(5, 0)], new Array(), );
 m_arrChordPatterns[m_cpMajor].PatternGuitar[3] = new Placement(4, m_Guitar, 7, [new Fingering(1, 2)], [new Fingering(0, 3)], [new Fingering(5, 3)], new Array(), [new Fingering(2, 0), new Fingering(3, 0), new Fingering(4, 0)], new Array(), );
 m_arrChordPatterns[m_cpMajor].PatternGuitar[4] = new Placement(5, m_Guitar, 9, [new Fingering(4, 2)], [new Fingering(3, 2)], [new Fingering(2, 2)], new Array(), [new Fingering(1, 0), new Fingering(5, 0)], [new Fingering(0, 0)], );
 m_arrChordPatterns[m_cpMajor].PatternMandolin[0] = new Placement(6, m_Mandolin, 7, [new Fingering(2, 2)], [new Fingering(3, 3)], new Array(), new Array(), [new Fingering(0, 0), new Fingering(1, 0)], new Array(), );
 m_arrChordPatterns[m_cpMajor].PatternMandolin[1] = new Placement(7, m_Mandolin, 0, [new Fingering(1, 2)], [new Fingering(2, 3)], new Array(), new Array(), [new Fingering(0, 0), new Fingering(3, 0)], new Array(), );
 m_arrChordPatterns[m_cpMajor].PatternMandolin[2] = new Placement(8, m_Mandolin, 2, [new Fingering(0, 2)], [new Fingering(3, 2)], new Array(), new Array(), [new Fingering(1, 0), new Fingering(2, 0)], new Array(), );
 m_arrChordPatterns[m_cpMajor].PatternMandolin[3] = new Placement(9, m_Mandolin, 5, [new Fingering(3, 1)], [new Fingering(1, 3)], [new Fingering(0, 5)], new Array(), [new Fingering(2, 0)], new Array(), );
 m_arrChordPatterns[m_cpMajor].PatternMandolin[4] = new Placement(10, m_Mandolin, 4, [new Fingering(1, 2), new Fingering(2, 2)], new Array(), new Array(), [new Fingering(3, 4)], new Array(), [new Fingering(0, 0)], );
 m_arrChordPatterns[m_cpMajor].PatternMandolin[5] = new Placement(11, m_Mandolin, 9, [new Fingering(0, 2), new Fingering(1, 2)], new Array(), new Array(), new Array(), [new Fingering(2, 0), new Fingering(3, 0)], new Array(), );
 m_arrChordPatterns[m_cpMajor].PatternMandolin[6] = new Placement(12, m_Mandolin, 11, [new Fingering(1, 1)], [new Fingering(2, 2)], [new Fingering(3, 2)], [new Fingering(0, 4)], new Array(), new Array(), );
 m_arrChordPatterns[m_cpMinor].PatternGuitar[0] = new Placement(13, m_Guitar, 9, [new Fingering(4, 1)], [new Fingering(2, 2)], [new Fingering(3, 2)], new Array(), [new Fingering(1, 0), new Fingering(5, 0)], [new Fingering(0, 0)], );
 m_arrChordPatterns[m_cpMinor].PatternGuitar[1] = new Placement(14, m_Guitar, 2, [new Fingering(5, 1)], [new Fingering(3, 2)], [new Fingering(4, 3)], new Array(), [new Fingering(2, 0)], [new Fingering(0, 0), new Fingering(1, 0)], );
 m_arrChordPatterns[m_cpMinor].PatternGuitar[2] = new Placement(15, m_Guitar, 4, [new Fingering(1, 2)], [new Fingering(2, 2)], new Array(), new Array(), [new Fingering(0, 0), new Fingering(3, 0), new Fingering(4, 0), new Fingering(5, 0)], new Array(), );
 m_arrChordPatterns[m_cpMinor].PatternMandolin[0] = new Placement(16, m_Mandolin, 9, [new Fingering(0, 2)], [new Fingering(1, 2)], [new Fingering(2, 3)], new Array(), [new Fingering(3, 0)], new Array(), );
 m_arrChordPatterns[m_cpMinor].PatternMandolin[1] = new Placement(17, m_Mandolin, 4, new Array(), [new Fingering(1, 2)], [new Fingering(2, 2)], new Array(), [new Fingering(0, 0), new Fingering(3, 0)], new Array(), );
 m_arrChordPatterns[m_cpMinor].PatternMandolin[2] = new Placement(18, m_Mandolin, 11, [new Fingering(2, 2), new Fingering(3, 2)], new Array(), [new Fingering(0, 4)], new Array(), [new Fingering(1, 0)], new Array(), );
 m_arrChordPatterns[m_cpMinor].PatternMandolin[3] = new Placement(19, m_Mandolin, 7, new Array(), new Array(), [new Fingering(2, 1)], [new Fingering(3, 3)], [new Fingering(0, 0), new Fingering(1, 0)], new Array(), );
 m_arrChordPatterns[m_cpMinor].PatternMandolin[4] = new Placement(20, m_Mandolin, 2, [new Fingering(3, 1)], [new Fingering(0, 2)], new Array(), new Array(), [new Fingering(1, 0), new Fingering(2, 0)], new Array(), );
 m_arrChordPatterns[m_cpDim].PatternGuitar[0] = new Placement(21, m_Guitar, 9, [new Fingering(2, 1)], [new Fingering(3, 2)], [new Fingering(4, 1)], new Array(), [new Fingering(1, 0)], [new Fingering(0, 0), new Fingering(5, 0)], );
}
function makeBarreChordPatterns()
{                                                                    //   index                                                                                                                                              // middle             // ring               // pinky         // no play          
 m_GuitarBarreChordE = new BarrePlacement(1, 4, m_cpMajor, m_Guitar, [new BarreIndex(0, 0, 1), new BarreIndex(1, 0, 0), new BarreIndex(2, 0, 0), new BarreIndex(3, 0, 0), new BarreIndex(4, 0, 1), new BarreIndex(5, 0, 1)], [new Fingering(3, 1)], [new Fingering(1, 2)], [new Fingering(2, 2)], new Array());
 m_GuitarBarreChordEm = new BarrePlacement(2, 4, m_cpMinor, m_Guitar, [new BarreIndex(0, 0, 1), new BarreIndex(1, 0, 0), new BarreIndex(2, 0, 0), new BarreIndex(3, 0, 1), new BarreIndex(4, 0, 1), new BarreIndex(5, 0, 1)], new Array(), [new Fingering(1, 2)], [new Fingering(2 ,2)], new Array());
                                                                      // low e is not root of chord on this barre so is shown as no play 
 m_GuitarBarreChordA = new BarrePlacement(3, 9, m_cpMajor, m_Guitar, [new BarreIndex(1, 0, 1), new BarreIndex(2, 0, 0), new BarreIndex(3, 0, 0), new BarreIndex(4, 0, 0), new BarreIndex(5, 0, 1)], new Array(), [new Fingering(2, 2), new Fingering(3, 2), new Fingering(4, 2)], new Array(), [new Fingering(0, 0)]);
 m_GuitarBarreChordAm = new BarrePlacement(4, 9, m_cpMinor, m_Guitar, [new BarreIndex(1, 0, 1), new BarreIndex(2, 0, 0), new BarreIndex(3, 0, 0), new BarreIndex(4, 0, 0), new BarreIndex(5, 0, 1)], [new Fingering(4, 1)], [new Fingering(2, 2)], [new Fingering(3, 2)], [new Fingering(0, 0)]);
                                                                       // index                   // middle
 m_GuitarBarreChordAd = new BarrePlacement(4, 9, m_cpMinor, m_Guitar, [new BarreIndex(1, 0, 1)], [new Fingering(2, 1)], [new Fingering(3, 2)], [new Fingering(4, 1)], [new Fingering(0, 0), new Fingering(5,0)]);
 
                                                                        // index                                                                                        // middle     // ring                // pinky               // no play
 m_MandolinBarreChordD = new BarrePlacement(5, 2, m_cpMajor, m_Mandolin, [new BarreIndex(0,0,0), new BarreIndex(1,0,1), new BarreIndex(2,0,1), new BarreIndex(3,0,0)], new Array(), [new Fingering(0, 2)], [new Fingering(3,2)], new Array());
 m_MandolinBarreChordDm = new BarrePlacement(6, 2, m_cpMinor, m_Mandolin, [new BarreIndex(0,0,0), new BarreIndex(1,0,1), new BarreIndex(2,0,1), new BarreIndex(3,0,0)], [new Fingering(3,1)], [new Fingering(0, 2)], new Array(), new Array());

}

function makeGuitar() // midi notes of guitar strings, 0 index is low E 
{
 var i;

 m_arrGuitar[0] = new Array();
 m_arrGuitar[1] = new Array();
 m_arrGuitar[2] = new Array();
 m_arrGuitar[3] = new Array();
 m_arrGuitar[4] = new Array();
 m_arrGuitar[5] = new Array();

 for (i=0; i<m_arrInstruments[m_Guitar].Frets; i++)
  {
   m_arrGuitar[0].push(m_arrInstruments[m_Guitar].Tunings[m_CurrentGuitarTuning].TuningMidiNotes[0] + i);
   m_arrGuitar[1].push(m_arrInstruments[m_Guitar].Tunings[m_CurrentGuitarTuning].TuningMidiNotes[1] + i);
   m_arrGuitar[2].push(m_arrInstruments[m_Guitar].Tunings[m_CurrentGuitarTuning].TuningMidiNotes[2] + i);
   m_arrGuitar[3].push(m_arrInstruments[m_Guitar].Tunings[m_CurrentGuitarTuning].TuningMidiNotes[3] + i);
   m_arrGuitar[4].push(m_arrInstruments[m_Guitar].Tunings[m_CurrentGuitarTuning].TuningMidiNotes[4] + i);
   m_arrGuitar[5].push(m_arrInstruments[m_Guitar].Tunings[m_CurrentGuitarTuning].TuningMidiNotes[5] + i);
  }
}

function makeBass() // midi notes of bass strings
{
 var i;

 m_arrBass[0] = new Array();
 m_arrBass[1] = new Array();
 m_arrBass[2] = new Array();
 m_arrBass[3] = new Array();

 for (i=0; i<m_arrInstruments[m_Bass].Frets; i++)
  {
   m_arrBass[0].push(m_arrInstruments[m_Bass].Tunings[m_CurrentBassTuning].TuningMidiNotes[0] + i);
   m_arrBass[1].push(m_arrInstruments[m_Bass].Tunings[m_CurrentBassTuning].TuningMidiNotes[1] + i);
   m_arrBass[2].push(m_arrInstruments[m_Bass].Tunings[m_CurrentBassTuning].TuningMidiNotes[2] + i);
   m_arrBass[3].push(m_arrInstruments[m_Bass].Tunings[m_CurrentBassTuning].TuningMidiNotes[3] + i);
  }
}

function makeMandolin() // midi notes of mandolin strings
{
 var i;

 m_arrMandolin[0] = new Array();
 m_arrMandolin[1] = new Array();
 m_arrMandolin[2] = new Array();
 m_arrMandolin[3] = new Array();

 for (i=0; i<m_arrInstruments[m_Mandolin].Frets; i++)
  {
   m_arrMandolin[0].push(m_arrInstruments[m_Mandolin].Tunings[m_CurrentMandolinTuning].TuningMidiNotes[0] + i);
   m_arrMandolin[1].push(m_arrInstruments[m_Mandolin].Tunings[m_CurrentMandolinTuning].TuningMidiNotes[1] + i);
   m_arrMandolin[2].push(m_arrInstruments[m_Mandolin].Tunings[m_CurrentMandolinTuning].TuningMidiNotes[2] + i);
   m_arrMandolin[3].push(m_arrInstruments[m_Mandolin].Tunings[m_CurrentMandolinTuning].TuningMidiNotes[3] + i);
  }
}

function makeUkulele() // midi notes of ukulele strings
{
 var i;

 m_arrUkulele[0] = new Array();
 m_arrUkulele[1] = new Array();
 m_arrUkulele[2] = new Array();
 m_arrUkulele[3] = new Array();

 for (i=0; i<m_arrInstruments[m_Ukulele].Frets; i++)
  {
   m_arrUkulele[0].push(m_arrInstruments[m_Ukulele].Tunings[m_CurrentUkuleleTuning].TuningMidiNotes[0] + i);
   m_arrUkulele[1].push(m_arrInstruments[m_Ukulele].Tunings[m_CurrentUkuleleTuning].TuningMidiNotes[1] + i);
   m_arrUkulele[2].push(m_arrInstruments[m_Ukulele].Tunings[m_CurrentUkuleleTuning].TuningMidiNotes[2] + i);
   m_arrUkulele[3].push(m_arrInstruments[m_Ukulele].Tunings[m_CurrentUkuleleTuning].TuningMidiNotes[3] + i);
  }
}

// Utility functions

function NoteText(iOffset) // this exists to provide note info if the note is out of key
{
 var offset;

 if (iOffset > 11)
   offset = iOffset - 12;
 else  
   offset = iOffset;

 switch(offset)
  {
   case  0: return "c";
   case  1: return "c" + symSharp + "/" + "d" + symFlat;
   case  2: return "d";
   case  3: return "d" + symSharp + "/" + "e" + symFlat;
   case  4: return "e";
   case  5: return "f";
   case  6: return "f" + symSharp + "/" + "g" + symFlat;
   case  7: return "g";
   case  8: return "g" + symSharp + "/" + "a" + symFlat;
   case  9: return "a";
   case 10: return "a" + symSharp + "/" + "b" + symFlat;
   case 11: return "b";
  }
}

// if I want a spread with a total of 3
// 2 needs to be about half and 3 the final color
// 

function GetBlueGreenColor(ndx, total) // returns color string, ndx is which color, total is the number of colors in the spread
{
 // the classic ratio problem
 // actual is to ndx as total is to arr.length
 // ratio actual:ndx is equivalent to total:arr.length
 // that is actual/ndx = total/arr.length
 // solve for actual would be:  actual = (total/arr.length) * ndx

 var actual;
 var fltval;

 if (total == 0) 
   throw new Error("total cannot be 0");

 if (total > m_arrGradientBlueGreen.length)
   throw new Error("total is > than array of colors");

 if (ndx = 0)
   return m_arrGradientBlueGreen[0];

 if (ndx == total)
   return m_arrGradientBlueGreen[m_arrGradientBlueGreen.length - 1];

 if (total == m_arrGradientBlueGreen.length) // no algebra required
   return m_arrGradientBlueGreen[ndx];  

 fltval = (total / m_arrGradientBlueGreen.length) * ndx;

 actual = Math.round(fltval);

 return m_arrGradientBlueGreen[actual];
}

function FigureOutGradient(chord, offset, midi)  // chord note colors.  chord is ndx to m_arrChordPatterns, offset is chord starting note  c = 0, midi note #
{
 var off = m_mapMidiNotes.get(midi).Offset;
 var pat = m_arrChordPatterns[chord];
 var note;

 for(i=0; i<pat.Pitches.length; i++)
  {
   note = offset + pat.Pitches[i]; // pitches are not steps between notes
   if (note >= 12)
     note -= 12;
  
   if (note == off)
     return i;
  }

 return -1;
}

function MidiNoteInChord(chord, offset, midi)  // returns true if midi note is in the chord, root is offset
{
 var pat = m_arrChordPatterns[chord];
 var midiNote = m_mapMidiNotes.get(midi);
 var i, off;

 off = offset; // root of chord, c = 0

 for(i=0; i<pat.Pitches.length; i++) // 1st pitch in the array is 0
  {
   off = offset + pat.Pitches[i]; // pitches are not steps betweeen chords
   if (off >= 12) 
     off -= 12;
   if (off == midiNote.Offset)
     return true;
  }

 return false;
}

function PlayNote(midi, milli) 
{
 var oscillator; 
 var midiNote;

 if (m_Audio == null)
   m_Audio = new(window.AudioContext || window.webkitAudioContext)();

 midiNote = m_mapMidiNotes.get(midi);

 oscillator = m_Audio.createOscillator(); // create the player
 oscillator.type = 'square';
 oscillator.frequency.value = midiNote.Frequency;
 oscillator.connect(m_Audio.destination);
 oscillator.start();

 setTimeout(function(){oscillator.stop(); PlayMidiNotes(milli); }, milli); 
}

function PlayMidiNotes(milli)
{
 if (m_CurrentMidiNote < m_arrPlayMidi.length) 
  {
   PlayNote(m_arrPlayMidi[m_CurrentMidiNote], milli);
   m_CurrentMidiNote++;
  }
}

function PlayKeyScale()
{
 var start;
 var i;
 
 start = 48 + m_Key.Offset;  // c3
 m_arrPlayMidi = new Array();

 for (i=0; i<m_arrModes[m_CurrentMode].Sequences.length; i++)
  {
   m_arrPlayMidi[i] = start;
   start += m_arrModes[m_CurrentMode].Sequences[i]; // have to increment after it's consumed
  }
// m_arrPlayMidi.push(start + 12); // add the root's octave to give that completion sound
 m_CurrentMidiNote = 0;
 PlayMidiNotes(169);
}

function PlayChord(chord, offset) // using m_Key
{
 var start;
 var i;
 var midi;

 start = 48 + offset; // c3
 m_arrPlayMidi = new Array();

 for (i=0; i<m_arrChordPatterns[chord].Pitches.length; i++)
  {
   midi = start + m_arrChordPatterns[chord].Pitches[i];
   m_arrPlayMidi[i] = midi;   
  }

 m_CurrentMidiNote = 0;
 PlayMidiNotes(69);
}

function PlaySingleNote(midi)
{

 m_arrPlayMidi = new Array();
 m_arrPlayMidi[0] = midi;
 m_CurrentMidiNote = 0;
 PlayMidiNotes(250);
}
////////////////////////////////////////////////
//       G e n e r a t e    H T M L
////////////////////////////////////////////////

function GenChordInfo(chord, offset, key) // chord pattern index, offset is chord's starting note C = 0, Key object
{
 var pattern;
 var html;
 var note, noteText;
 var p, k;
 var midi;

 pattern = m_arrChordPatterns[chord]; // grab ChordPattern from modes array so it can step up through the notes
 
 note = key.OffsetNote(offset);
 if (note == null)
   noteText = NoteText(offset);
 else 
   noteText = note.Text;

 html = "<table>"; 

 html += "<tr><td class='chordInfo' onclick='PlayChord(" + chord.toString() + "," + offset.toString() + ");' colspan=2>" + noteText;
 html += pattern.ShortName;
 html += "</td></tr>";

 for (p=0; p<pattern.Pitches.length; p++)
  {
   midi = 48 + offset + pattern.Pitches[p];
   k = offset + pattern.Pitches[p];
   if (k>11)
     k -= 12;

  if (p > 0)
   {
    html += "<TR><TD class='chordFormula'>"; 
    switch(p)
     {
      case 1: html += pattern.Third; break;
      case 2: html += pattern.Fifth; break;
      case 3: html += pattern.Seventh; break;
      case 4: html += pattern.Ninth; break;
     }
    html += "<TD class='chordStep'>" + pattern.Pitches[p].toString() + "</TD>";
    html += "</TD></TR>";
   }

   html += "<TR><TD class='chordNote' onclick='PlaySingleNote(" + midi.toString() + ");' style='color:#000044; background-color:" + m_arrPastels[p] + ";' colspan=2>";

   note = key.OffsetNote(k);
   if (note == null)
     noteText = NoteText(k);
   else 
     noteText = note.Text;

   html += noteText; // dm7 0-3-7-10 :  2 = d, 5 = f, 9 = a, 12  = c
   html += "</TD></TR>";
  }

 html += "</table>";

 return html;
}

function GenScaleInfo(key) // chord pattern index, offset C = 0, Key object
{
 var s="";
 var i;
 var midi = 48 + key.Offset; // 48 is C3

 for (i=0;i<m_arrModes[m_CurrentMode].Sequences.length;i++)
  {
   s += "<TD class='scaleNote' style='background-color:" + m_arrGradientBlueGreen[i] + ";' onclick='PlaySingleNote(" + midi + ");'>";
   s += m_Key.Notes[i].Text;
   s += "</TD>";

   midi += m_arrModes[m_CurrentMode].Sequences[i]; // have to increment midi after it's consumed above

   s+="<TD class='modeSequence'>"; 
   switch(m_arrModes[m_CurrentMode].Sequences[i])
    {
     case 1: s+="h<BR />1"; break;
     case 2: s+="W<BR />2"; break;
     case 3: s+="m3<BR />3"; break;
     case 4: s+="M 3<BR />4"; break;
    }
   s+="</TD>";
  }

 return s;
}

function genModeChords()
{
 var pattern;
 var s;
 var cn;
 
 s="<TABLE>";
 s+="<TR><TD class='scaleInfo'>Chord Progression</TD>";

 cn = m_Key.Offset;

 for (i=0;i<m_arrModes[m_CurrentMode].Sequences.length;i++)
  {
   pattern = m_arrModes[m_CurrentMode].ChordType[i];
   s += "<TD class='modeChord' onclick='PlayChord(" + pattern.toString() + "," + cn.toString() + ");'>";
   
   s += m_Key.OffsetNote(cn).Text;
   s += m_arrChordPatterns[pattern].ShortName;
  
   s += "</TD>";

   s+="<TD class='modeSequence'>"; 
   switch(m_arrModes[m_CurrentMode].Sequences[i])
    {
     case 1: s+="h<BR />1"; break;
     case 2: s+="W<BR />2"; break;
     case 3: s+="m3<BR />3"; break;
     case 4: s+="M 3<BR />4"; break;
    }
   s+="</TD>";

   cn += m_arrModes[m_CurrentMode].Sequences[i];
   if (cn >= 12)
     cn -= 12;
  }
 s+="</TR><TR></TABLE>";

 return s;
}

////////////////////////////////////////////////
//                 G u i t a r     
////////////////////////////////////////////////

// generate guitar fretboard
// returns a open chord fingering letter I,M,R,P or O, X based on string and fret
// m_arrChordPatterns has been prepared that contain the fingering

function GenGuitarStringElement(chord, offset, wstr, fret) // chord = chord pattern index, offset c=0, wstr is string #, fret # nut is 0
{
 var i, k;

 for (i=0; i<m_arrChordPatterns[chord].PatternGuitar.length; i++) // go thru the placements
  {
   if (m_arrChordPatterns[chord].PatternGuitar[i].Offset == offset) // see if offset is present C = 0
    {
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Index.length; k++) // go thru Index finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Index[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Index[k].Fret == fret)
         return "I"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Middle.length; k++) // go thru middle finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Middle[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Middle[k].Fret == fret)
         return "M"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Ring.length; k++) // go thru ring finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Ring[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Ring[k].Fret == fret)
         return "R"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Pinky.length; k++) // go thru pinky finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Pinky[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Pinky[k].Fret == fret)
         return "P"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Open.length; k++) // go thru open string list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Open[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Open[k].Fret == fret)
         return "O"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].NoPlay.length; k++) // go thru no play finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].NoPlay[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].NoPlay[k].Fret == fret)
         return "X"; 
      }
    }
  }
 return "";
}

// return barre chord fingering I,M,R,P or X based on string and fret
// each barre pattern, E and A types were prepared.
// the Offsets array for each contains the offset to the barre pattern fingering array
// the offset gives the location of the barre chord for the passed offset. For the A and Am pattern C = 0 would return 2 which is the A pattern up the 3rd fret.
// the reason C is not 3 is because the open A is not included in the fingering, only barre chords are present.  

function GenGuitarBarreStringElement(chord, offset, wstr, fret) // ChordPatteren index, offset C=0, String # (low E is 0), fret # (nut is 0)
{ 
 // for barre need to not return fingerings for open A and open E
 if (chord == m_cpMajor)
  {
   fo = m_GuitarBarreChordA.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordA.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Index[fo][k].Str == wstr && m_GuitarBarreChordA.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordA.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Middle[fo][k].Str == wstr && m_GuitarBarreChordA.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordA.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Ring[fo][k].Str == wstr && m_GuitarBarreChordA.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordA.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Pinky[fo][k].Str == wstr && m_GuitarBarreChordA.Pinky[fo][k].Fret == fret)
       return "P";
    }
   for (k=0; k<m_GuitarBarreChordA.NoPlay[fo].length; k++)
    {
     if (m_GuitarBarreChordA.NoPlay[fo][k].Str == wstr && m_GuitarBarreChordA.NoPlay[fo][k].Fret == fret)
       return "X";
    }
   fo = m_GuitarBarreChordE.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordE.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Index[fo][k].Str == wstr && m_GuitarBarreChordE.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordE.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Middle[fo][k].Str == wstr && m_GuitarBarreChordE.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordE.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Ring[fo][k].Str == wstr && m_GuitarBarreChordE.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordE.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Pinky[fo][k].Str == wstr && m_GuitarBarreChordE.Pinky[fo][k].Fret == fret)
       return "P";
    }
  }
 if (chord == m_cpMinor)
  {
   fo = m_GuitarBarreChordAm.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordAm.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Index[fo][k].Str == wstr && m_GuitarBarreChordAm.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordAm.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Middle[fo][k].Str == wstr && m_GuitarBarreChordAm.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordAm.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Ring[fo][k].Str == wstr && m_GuitarBarreChordAm.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordAm.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Pinky[fo][k].Str == wstr && m_GuitarBarreChordAm.Pinky[fo][k].Fret == fret)
       return "P";
    }
   for (k=0; k<m_GuitarBarreChordAm.NoPlay[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.NoPlay[fo][k].Str == wstr && m_GuitarBarreChordAm.NoPlay[fo][k].Fret == fret)
       return "X";
    }
   fo = m_GuitarBarreChordEm.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordEm.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Index[fo][k].Str == wstr && m_GuitarBarreChordEm.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordEm.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Middle[fo][k].Str == wstr && m_GuitarBarreChordEm.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordEm.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Ring[fo][k].Str == wstr && m_GuitarBarreChordEm.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordEm.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Pinky[fo][k].Str == wstr && m_GuitarBarreChordEm.Pinky[fo][k].Fret == fret)
       return "P";
    }
  }
 if (chord == m_cpDim)
  {
   fo = m_GuitarBarreChordAd.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordAd.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordAd.Index[fo][k].Str == wstr && m_GuitarBarreChordAd.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordAd.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordAd.Middle[fo][k].Str == wstr && m_GuitarBarreChordAd.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordAd.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordAd.Ring[fo][k].Str == wstr && m_GuitarBarreChordAd.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordAd.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordAd.Pinky[fo][k].Str == wstr && m_GuitarBarreChordAd.Pinky[fo][k].Fret == fret)
       return "P";
    }
   for (k=0; k<m_GuitarBarreChordAd.NoPlay[fo].length; k++)
    {
     if (m_GuitarBarreChordAd.NoPlay[fo][k].Str == wstr && m_GuitarBarreChordAd.NoPlay[fo][k].Fret == fret)
       return "X";
    }
  }
 return "";
}

// Show Note gets the ShowNote property of the BarreIndex object for barre chord fingerings
// the Offset lookup system is the same as GenGuitarBarreStringElement above

function GenGuitarBarreShowNote(chord, offset, wstr, fret) // chord (index to m_arrChordPattern), offset c=0, string (low = 0), fret #
{ 
 // for barre need to not return fingerings for open A and open E
 if (chord == m_cpMajor)
  {
   fo = m_GuitarBarreChordA.Offsets[offset]; // if offset = 0, C, fo = 2
   for (k=0; k<m_GuitarBarreChordA.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Index[fo][k].Str == wstr && m_GuitarBarreChordA.Index[fo][k].Fret == fret)
       return m_GuitarBarreChordA.Index[fo][k].ShowNote;
    }
   fo = m_GuitarBarreChordE.Offsets[offset];  // if offset = 0, c, fo = 7
   for (k=0; k<m_GuitarBarreChordE.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Index[fo][k].Str == wstr && m_GuitarBarreChordE.Index[fo][k].Fret == fret)
       return m_GuitarBarreChordE.Index[fo][k].ShowNote;
    }
  }
 if (chord == m_cpMinor)
  {
   fo = m_GuitarBarreChordAm.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordAm.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Index[fo][k].Str == wstr && m_GuitarBarreChordAm.Index[fo][k].Fret == fret)
       return m_GuitarBarreChordAm.Index[fo][k].ShowNote;
    }
   fo = m_GuitarBarreChordEm.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordEm.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Index[fo][k].Str == wstr && m_GuitarBarreChordEm.Index[fo][k].Fret == fret)
       return m_GuitarBarreChordEm.Index[fo][k].ShowNote;
    }
  }
 return 1;
}

// generate a TR html for a guitar string for a specific chord

function GenGuitarString(chord, offset, wstr, key) // index to ChordPattern, offset C=0, string # low E is 0, Key object
{
 var midi;
 var barre, fb, barreShowNote;
 var html = "<tr>";
 var fret;
 var gradient;
 var sw = fretStartSize; // 40 pixels
 var w;
 var inChord;

 for (fret=0; fret<m_arrInstruments[m_Guitar].Frets; fret++)
  {
   midi = m_arrGuitar[wstr][fret]; // get midi note of string and fret
   
   if (fret == 0) // before the nut
     w = fretBeforeNut;   // 25 pixels
   else  
     w = sw;
   html += "<td class='fretString' onclick='PlaySingleNote(" + midi.toString() + ");'>";

  

   inChord = MidiNoteInChord(chord, offset, midi); // is the midi note in the chord?

   fb = GenGuitarStringElement(chord, offset, wstr, fret); // returns a finger letter or O X  for open chords
   barre = GenGuitarBarreStringElement(chord, offset, wstr, fret); // returns barre equivilent for barre chords
   barreShowNote = GenGuitarBarreShowNote(chord, offset, wstr, fret); // if it's "I" index do I show the note
   gradient = FigureOutGradient(chord, offset, midi);  // returns which color to use

   html += GenGuitarCell(w, fb, barre, midi, barreShowNote, key, gradient, inChord);  // figure out the html for a fret cell
  
   html += "</td>";
   sw -=  fretDecrease; // 1 pixel
  }
 html += "</tr>";
 return html;
}

function GenGuitarStringScale(wstr, key) // index to ChordPattern, offset C=0, string # low E is 0, Key object
{
 var midi;
 var bg, fg;
 var sn;
 var html = "<tr>";
 var fret;
 var sw = fretStartSize; //vw units about 40 pixels on a 1920 display, this is the size of area between the nut and fret 1
 var w;

 for (fret=0; fret<m_arrInstruments[m_Guitar].Frets; fret++)
  {
   midi = m_arrGuitar[wstr][fret]; // get midi note of string and fret
   
   sn = 0;
   for(i=0; i<key.Offsets.length; i++)
    {
     if (m_mapMidiNotes.get(midi).Offset == key.Offsets[i])
       sn = i+1;
    }

   if (sn > 0)
    {
     bg = m_arrGradientBlueGreen[sn-1];
     fg = "#000044";
    }
   else
    {
     bg = "#CCCCCC";
     fg = "white";
    }
   if (fret == 0)        // before the nut
     w = fretBeforeNut;  // 25 pixels
   else  
     w = sw;

   html += "<td class='fretString' style='color:" + fg + "; background-color:" + bg + ";' onclick='PlaySingleNote(" + midi.toString() + ");'>";

   html += GenGuitarCellScale(w, midi, sn, key);
  
   html += "</td>";
   sw -= fretDecrease; // subtract about a pixel on 1920 monitor
  }
 html += "</tr>";
 return html;
}

function GenGuitarMarks()
{
 var html = "<tr>";
 var fret;
 var sw = fretMarkStart; // 30 pixels, have to slide this over a bit to line up the dots like a fretboard

 for (fret=0; fret<m_arrInstruments[m_Guitar].Frets; fret++)
  {
   if (fret == 0) // before the nut
    {
     w = fretMarkBeforeNut;   // 15 pixels
    }
   else  
     w = sw;
   html += "<td class='fretMark' style='width:" + w.toString() + "vw;'>";
   if (fret == 0)
     html += "Nut";
   if (fret == 3 || fret == 5 || fret ==7 || fret == 9 || fret == 15 || fret==17 || fret==19) 
     html += symDot;
   if (fret == 12)
     html += symDot + symDot;
   html += "</td>";
   sw -= fretDecrease;
  }

 html += "</tr>";
 return html;
}


// return HTML for a guitar fret by string an fret #

function GenGuitarCell(width, open, barre, midiNote, barreShowNote, key, grad, inChord) // width is cell size, open & barre are fingering letter, barreShowNote is for index no play, key is Key object, 0 thru 5 gradient color of note based on step in chord
{
 var html;
 var note;
 var color;
 var midi

 midi = m_mapMidiNotes.get(midiNote);
 
 if (key.LookUp[midi.Offset] >= 0)
   note = midi.MidiName(key);
 else 
   note = NoteText(midi.Offset) + "(" + midi.Octave.toString() + ")"; 

 if (m_CurrentGuitarTuning == 0) // is it standard tuning?
  {
   if (open == "" && barre == "")
    {
     note = "";
    }
   else 
    {
     if (open == "X" || barre == "X")
       note = "";
     else 
      {
       if (barre == "I")
        {
         if (barreShowNote == 0)
           note = "";
        }
      }
    }
  }
 else // non standard tuning, just show notes that are in the chord
  {
   open = "";
   barre = "";
   if (inChord == false)
    {
     note = "";
    }   
  }

 if (note != "")
  {
   color = m_arrPastels[grad]; 
  }
 else
  {
   color = "#ffffff";
  }

 html = "<div class='fretCell' style='width:" + width.toString() + "vw; background-color:" + color + "'>";
 html += note;
 
 if (open != "")
   html += "<div class='fretCellLeft'>" + open + "</div>";

 if (barre != "")
   html += "<div class='fretCellRight'>" + barre + "</div>";

 html += "</div>";

 return html;
}

// return HTML for a string / fret cell for the scale fretboard

function GenGuitarCellScale(width, midiNote, scaleNum, key)
{
 var html;
 var note;

 if (key.LookUp[m_mapMidiNotes.get(midiNote).Offset] >= 0)
   note = m_mapMidiNotes.get(midiNote).MidiName(key);
 else 
   note = ""; 

 if (scaleNum == 0)
  {
   note = "";
  }

 html = "<div class='fretCell' style='width:" + width.toString() + "vw;'>";
 html += note;

 if (scaleNum > 0)
   html += "<div class='fretCellRight'>" + scaleNum.toString() + "</div>";

 html += "</div>";

 return html;
}

function GenGuitar(chord, offset, key) // chord pattern index, offset C=0, Key object
{
 var html;

 html = "<table>";

 html += GenGuitarString(chord, offset, 5, key);
 html += GenGuitarString(chord, offset, 4, key);
 html += GenGuitarString(chord, offset, 3, key);
 html += GenGuitarString(chord, offset, 2, key);
 html += GenGuitarString(chord, offset, 1, key);
 html += GenGuitarString(chord, offset, 0, key);
 html += GenGuitarMarks();

 html += "</table>";
  
 return html;
}

function GenGuitarScale(key)
{
 var html;

 html = "<table><tr><td><table><tr>" // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='scaleName' onclick='PlayKeyScale();'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrModes[m_CurrentMode].ModeName;
 html += " Scale";
 html += "</td>";

 html += GenScaleInfo(key);  // returns more TDs

 html += "</tr></table></tr></td><tr><td><table>";

 html += GenGuitarStringScale(5, key); // returns TRs
 html += GenGuitarStringScale(4, key);
 html += GenGuitarStringScale(3, key);
 html += GenGuitarStringScale(2, key);
 html += GenGuitarStringScale(1, key);
 html += GenGuitarStringScale(0, key);
 html += GenGuitarMarks();

 html += "</table></td></tr></table>";

 return html;
}

////////////////////////////////////////////////
//           B a s s    G u i t a r     
////////////////////////////////////////////////

// generate bass guitar fretboard.  Using the 1st 4 strings of guitar fingering patterns.
// returns a open chord fingering letter I,M,R,P or O, X based on string and fret
// m_arrChordPatterns has been prepared that contain the fingering

function GenBassStringElement(chord, offset, wstr, fret) // chord = chord pattern index, offset c=0, wstr is string #, fret # nut is 0
{
 var i, k;

 for (i=0; i<m_arrChordPatterns[chord].PatternGuitar.length; i++) // go thru the placements
  {
   if (m_arrChordPatterns[chord].PatternGuitar[i].Offset == offset) // see if offset is present C = 0
    {
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Index.length; k++) // go thru Index finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Index[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Index[k].Fret == fret)
         return "I"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Middle.length; k++) // go thru middle finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Middle[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Middle[k].Fret == fret)
         return "M"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Ring.length; k++) // go thru ring finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Ring[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Ring[k].Fret == fret)
         return "R"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Pinky.length; k++) // go thru pinky finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Pinky[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Pinky[k].Fret == fret)
         return "P"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].Open.length; k++) // go thru open string list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].Open[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].Open[k].Fret == fret)
         return "O"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternGuitar[i].NoPlay.length; k++) // go thru no play finger list
      {
       if (m_arrChordPatterns[chord].PatternGuitar[i].NoPlay[k].Str == wstr && m_arrChordPatterns[chord].PatternGuitar[i].NoPlay[k].Fret == fret)
         return "X"; 
      }
    }
  }
 return "";
}

// return barre chord fingering I,M,R,P or X based on string and fret
// each barre pattern, E and A types were prepared.
// the Offsets array for each contains the offset to the barre pattern fingering array
// the offset gives the location of the barre chord for the passed offset. For the A and Am pattern C = 0 would return 2 which is the A pattern up the 3rd fret.
// the reason C is not 3 is because the open A is not included in the fingering, only barre chords are present.  

function GenBassBarreStringElement(chord, offset, wstr, fret) // ChordPatteren index, offset C=0, String # (low E is 0), fret # (nut is 0)
{ 
 // for barre need to not return fingerings for open A and open E
 if (chord == m_cpMajor)
  {
   fo = m_GuitarBarreChordA.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordA.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Index[fo][k].Str == wstr && m_GuitarBarreChordA.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordA.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Middle[fo][k].Str == wstr && m_GuitarBarreChordA.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordA.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Ring[fo][k].Str == wstr && m_GuitarBarreChordA.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordA.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Pinky[fo][k].Str == wstr && m_GuitarBarreChordA.Pinky[fo][k].Fret == fret)
       return "P";
    }
   for (k=0; k<m_GuitarBarreChordA.NoPlay[fo].length; k++)
    {
     if (m_GuitarBarreChordA.NoPlay[fo][k].Str == wstr && m_GuitarBarreChordA.NoPlay[fo][k].Fret == fret)
       return "X";
    }
   fo = m_GuitarBarreChordE.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordE.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Index[fo][k].Str == wstr && m_GuitarBarreChordE.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordE.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Middle[fo][k].Str == wstr && m_GuitarBarreChordE.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordE.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Ring[fo][k].Str == wstr && m_GuitarBarreChordE.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordE.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Pinky[fo][k].Str == wstr && m_GuitarBarreChordE.Pinky[fo][k].Fret == fret)
       return "P";
    }
  }
 if (chord == m_cpMinor)
  {
   fo = m_GuitarBarreChordAm.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordAm.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Index[fo][k].Str == wstr && m_GuitarBarreChordAm.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordAm.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Middle[fo][k].Str == wstr && m_GuitarBarreChordAm.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordAm.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Ring[fo][k].Str == wstr && m_GuitarBarreChordAm.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordAm.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Pinky[fo][k].Str == wstr && m_GuitarBarreChordAm.Pinky[fo][k].Fret == fret)
       return "P";
    }
   for (k=0; k<m_GuitarBarreChordAm.NoPlay[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.NoPlay[fo][k].Str == wstr && m_GuitarBarreChordAm.NoPlay[fo][k].Fret == fret)
       return "X";
    }
   fo = m_GuitarBarreChordEm.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordEm.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Index[fo][k].Str == wstr && m_GuitarBarreChordEm.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordEm.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Middle[fo][k].Str == wstr && m_GuitarBarreChordEm.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordEm.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Ring[fo][k].Str == wstr && m_GuitarBarreChordEm.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordEm.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Pinky[fo][k].Str == wstr && m_GuitarBarreChordEm.Pinky[fo][k].Fret == fret)
       return "P";
    }
  }
 return "";
}

// Show Note gets the ShowNote property of the BarreIndex object for barre chord fingerings
// the Offset lookup system is the same as GenGuitarBarreStringElement above

function GenBassBarreShowNote(chord, offset, wstr, fret) // chord (index to m_arrChordPattern), offset c=0, string (low = 0), fret #
{ 
 // for barre need to not return fingerings for open A and open E
 if (chord == m_cpMajor)
  {
   fo = m_GuitarBarreChordA.Offsets[offset]; // if offset = 0, C, fo = 2
   for (k=0; k<m_GuitarBarreChordA.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Index[fo][k].Str == wstr && m_GuitarBarreChordA.Index[fo][k].Fret == fret)
       return m_GuitarBarreChordA.Index[fo][k].ShowNote;
    }
   fo = m_GuitarBarreChordE.Offsets[offset];  // if offset = 0, c, fo = 7
   for (k=0; k<m_GuitarBarreChordE.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Index[fo][k].Str == wstr && m_GuitarBarreChordE.Index[fo][k].Fret == fret)
       return m_GuitarBarreChordE.Index[fo][k].ShowNote;
    }
  }
 if (chord == m_cpMinor)
  {
   fo = m_GuitarBarreChordAm.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordAm.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Index[fo][k].Str == wstr && m_GuitarBarreChordAm.Index[fo][k].Fret == fret)
       return m_GuitarBarreChordAm.Index[fo][k].ShowNote;
    }
   fo = m_GuitarBarreChordEm.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordEm.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Index[fo][k].Str == wstr && m_GuitarBarreChordEm.Index[fo][k].Fret == fret)
       return m_GuitarBarreChordEm.Index[fo][k].ShowNote;
    }
  }
 return 1;
}

// generate a TR html for a guitar string for a specific chord

function GenBassString(chord, offset, wstr, key) // index to ChordPattern, offset C=0, string # low E is 0, Key object
{
 var midi;
 var barre, fb, barreShowNote;
 var html = "<tr>";
 var fret;
 var gradient;
 var sw = fretStartSize; // 40 pixels
 var inChord;
 var w;

 for (fret=0; fret<m_arrInstruments[m_Bass].Frets; fret++)
  {
   if (fret == 0) // before the nut
     w = fretBeforeNut;   // 25 pixels
   else  
     w = sw;
   html += "<td class='fretString'>";

   midi = m_arrBass[wstr][fret]; // get midi note of string and fret
   inChord = MidiNoteInChord(chord, offset, midi); // is midi in the chord?
   fb = GenBassStringElement(chord, offset, wstr, fret);
   barre = GenBassBarreStringElement(chord, offset, wstr, fret);
   barreShowNote = GenBassBarreShowNote(chord, offset, wstr, fret);
   gradient = FigureOutGradient(chord, offset, midi);

   html += GenBassCell(w, fb, barre, midi, barreShowNote, key, gradient, inChord);
  
   html += "</td>";
   sw -=  fretDecrease; // 1 pixel
  }
 html += "</tr>";
 return html;
}

function GenBassStringScale(wstr, key) // index to ChordPattern, offset C=0, string # low E is 0, Key object
{
 var midi;
 var bg, fg;
 var sn;
 var html = "<tr>";
 var fret;
 var sw = fretStartSize; //vw units about 40 pixels on a 1920 display, this is the size of area between the nut and fret 1
 var w;

 for (fret=0; fret<m_arrInstruments[m_Bass].Frets; fret++)
  {
   midi = m_arrBass[wstr][fret]; // get midi note of string and fret
   
   sn = 0;
   for(i=0; i<key.Offsets.length; i++)
    {
     if (m_mapMidiNotes.get(midi).Offset == key.Offsets[i])
       sn = i+1;
    }

   if (sn > 0)
    {
     bg = m_arrGradientBlueGreen[sn-1];
     fg = "#000044";
    }
   else
    {
     bg = "#CCCCCC";
     fg = "white";
    }
   if (fret == 0)        // before the nut
     w = fretBeforeNut;  // 25 pixels
   else  
     w = sw;

   html += "<td class='fretString' style='color:" + fg + "; background-color:" + bg + ";'>";

   html += GenGuitarCellScale(w, midi, sn, key);
  
   html += "</td>";
   sw -= fretDecrease; // subtract about a pixel on 1920 monitor
  }
 html += "</tr>";
 return html;
}

function GenBassMarks()
{
 var html = "<tr>";
 var fret;
 var sw = fretMarkStart; // 30 pixels, have to slide this over a bit to line up the dots like a fretboard

 for (fret=0; fret<m_arrInstruments[m_Bass].Frets; fret++)
  {
   if (fret == 0) // before the nut
     w = fretMarkBeforeNut;   // 15 pixels
   else  
     w = sw;
   html += "<td class='fretMark' style='width:" + w.toString() + "vw;'>";
   if (fret == 0)
     html += "Nut";
   if (fret == 3 || fret == 5 || fret ==7 || fret == 9 || fret == 15 || fret==17 || fret==19) 
     html += symDot;
   if (fret == 12)
     html += symDot + symDot;
   html += "</td>";
   sw -= fretDecrease;
  }

 html += "</tr>";
 return html;
}


// return HTML for a bass guitar fret by string an fret #

function GenBassCell(width, open, barre, midiNote, barreShowNote, key, grad, inChord) // width is cell size, open & barre are fingering letter, barreShowNote is for index no play, key is Key object, 0 thru 5 gradient color of note based on step in chord
{
 var html;
 var note;
 var color;
 var midi;

 midi = m_mapMidiNotes.get(midiNote);
 
 if (key.LookUp[midi.Offset] >= 0)
   note = midi.MidiName(key);
 else 
   note = NoteText(midi.Offset) + "(" + midi.Octave.toString() + ")"; 

if (m_CurrentBassTuning == 0) // is it standard tuning?
  {
   if (open == "" && barre == "")
    {
     note = "";
    }
   else 
    {
     if (open == "X" || barre == "X")
       note = "";
     else 
      {
       if (barre == "I")
        {
         if (barreShowNote == 0)
           note = "";
        }
      }
    }
  }
 else // non standard tuning, just show notes that are in the chord
  {
   open = "";
   barre = "";
   if (inChord == false)
    {
     note = "";
    }   
  }

 if (note != "")
  {
   color = m_arrPastels[grad]; 
  }
 else
  {
   color = "#ffffff";
  }

 html = "<div class='fretCell' style='width:" + width.toString() + "vw; background-color:" + color + "'>";
 html += note;
 
 if (open != "")
   html += "<div class='fretCellLeft'>" + open + "</div>";

 if (barre != "")
   html += "<div class='fretCellRight'>" + barre + "</div>";

 html += "</div>";

 return html;
}

// return HTML for a string / fret cell for the scale fretboard

function GenBassCellScale(width, midiNote, scaleNum, key)
{
 var html;
 var note;

 if (key.LookUp[m_mapMidiNotes.get(midiNote).Offset] >= 0)
   note = m_mapMidiNotes.get(midiNote).MidiName(key);
 else 
   note = ""; 

 if (scaleNum == 0)
  {
   note = "";
  }

 html = "<div class='fretCell' style='width:" + width.toString() + "vw;'>";
 html += note;

 if (scaleNum > 0)
   html += "<div class='fretCellRight'>" + scaleNum.toString() + "</div>";

 html += "</div>";

 return html;
}

function GenBass(chord, offset, key) // chord pattern index, offset C=0, Key object
{
 var html;

 html = "<table>";

 html += GenBassString(chord, offset, 3, key);
 html += GenBassString(chord, offset, 2, key);
 html += GenBassString(chord, offset, 1, key);
 html += GenBassString(chord, offset, 0, key);

 html += GenBassMarks();

 html += "</table>";
  
 return html;
}

function GenBassScale(key)
{
 var html;

 html = "<table><tr><td><table><tr>" // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='scaleName' onclick='PlayKeyScale();'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrModes[m_CurrentMode].ModeName;
 html += " Scale";
 html += "</td>";

 html += GenScaleInfo(key);  // returns more TDs

 html += "</tr></table></tr></td><tr><td><table>";

 html += GenBassStringScale(3, key); // return TRs
 html += GenBassStringScale(2, key);
 html += GenBassStringScale(1, key);
 html += GenBassStringScale(0, key);
 html += GenBassMarks();

 html += "</table></td></tr></table>";

 return html;
}

////////////////////////////////////////////////
//             M a n d o l i n 
////////////////////////////////////////////////

// generate mandolin fretboard
// returns a open chord fingering letter I,M,R,P or O, X based on string and fret
// m_arrChordPatterns has been prepared that contain the fingering

function GenMandolinStringElement(chord, offset, wstr, fret) // chord = chord pattern index, offset c=0, wstr is string #, fret # nut is 0
{
 var i, k;

 for (i=0; i<m_arrChordPatterns[chord].PatternMandolin.length; i++) // go thru the placements
  {
   if (m_arrChordPatterns[chord].PatternMandolin[i].Offset == offset) // see if offset is present C = 0
    {
     for(k=0; k<m_arrChordPatterns[chord].PatternMandolin[i].Index.length; k++) // go thru Index finger list
      {
       if (m_arrChordPatterns[chord].PatternMandolin[i].Index[k].Str == wstr && m_arrChordPatterns[chord].PatternMandolin[i].Index[k].Fret == fret)
         return "I"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternMandolin[i].Middle.length; k++) // go thru middle finger list
      {
       if (m_arrChordPatterns[chord].PatternMandolin[i].Middle[k].Str == wstr && m_arrChordPatterns[chord].PatternMandolin[i].Middle[k].Fret == fret)
         return "M"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternMandolin[i].Ring.length; k++) // go thru ring finger list
      {
       if (m_arrChordPatterns[chord].PatternMandolin[i].Ring[k].Str == wstr && m_arrChordPatterns[chord].PatternMandolin[i].Ring[k].Fret == fret)
         return "R"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternMandolin[i].Pinky.length; k++) // go thru pinky finger list
      {
       if (m_arrChordPatterns[chord].PatternMandolin[i].Pinky[k].Str == wstr && m_arrChordPatterns[chord].PatternMandolin[i].Pinky[k].Fret == fret)
         return "P"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternMandolin[i].Open.length; k++) // go thru open string list
      {
       if (m_arrChordPatterns[chord].PatternMandolin[i].Open[k].Str == wstr && m_arrChordPatterns[chord].PatternMandolin[i].Open[k].Fret == fret)
         return "O"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternMandolin[i].NoPlay.length; k++) // go thru no play finger list
      {
       if (m_arrChordPatterns[chord].PatternMandolin[i].NoPlay[k].Str == wstr && m_arrChordPatterns[chord].PatternMandolin[i].NoPlay[k].Fret == fret)
         return "X"; 
      }
    }
  }
 return "";
}

// return barre chord fingering I,M,R,P or X based on string and fret
// each barre pattern, E and A types were prepared.
// the Offsets array for each contains the offset to the barre pattern fingering array
// the offset gives the location of the barre chord for the passed offset. For the A and Am pattern C = 0 would return 2 which is the A pattern up the 3rd fret.
// the reason C is not 3 is because the open A is not included in the fingering, only barre chords are present.  

function GenMandolinBarreStringElement(chord, offset, wstr, fret) // ChordPatteren index, offset C=0, String # (low E is 0), fret # (nut is 0)
{ 
 // for barre need to not return fingerings for open A and open E
 if (chord == m_cpMajor)
  {
   fo = m_MandolinBarreChordD.Offsets[offset];
   for (k=0; k<m_MandolinBarreChordD.Index[fo].length; k++)
    {
     if (m_MandolinBarreChordD.Index[fo][k].Str == wstr && m_MandolinBarreChordD.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_MandolinBarreChordD.Middle[fo].length; k++)
    {
     if (m_MandolinBarreChordD.Middle[fo][k].Str == wstr && m_MandolinBarreChordD.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_MandolinBarreChordD.Ring[fo].length; k++)
    {
     if (m_MandolinBarreChordD.Ring[fo][k].Str == wstr && m_MandolinBarreChordD.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_MandolinBarreChordD.Pinky[fo].length; k++)
    {
     if (m_MandolinBarreChordD.Pinky[fo][k].Str == wstr && m_MandolinBarreChordD.Pinky[fo][k].Fret == fret)
       return "P";
    }
   for (k=0; k<m_MandolinBarreChordD.NoPlay[fo].length; k++)
    {
     if (m_MandolinBarreChordD.NoPlay[fo][k].Str == wstr && m_MandolinBarreChordD.NoPlay[fo][k].Fret == fret)
       return "X";
    }
  }
 if (chord == m_cpMinor)
  {
   fo = m_MandolinBarreChordDm.Offsets[offset];
   for (k=0; k<m_MandolinBarreChordDm.Index[fo].length; k++)
    {
     if (m_MandolinBarreChordDm.Index[fo][k].Str == wstr && m_MandolinBarreChordDm.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_MandolinBarreChordDm.Middle[fo].length; k++)
    {
     if (m_MandolinBarreChordDm.Middle[fo][k].Str == wstr && m_MandolinBarreChordDm.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_MandolinBarreChordDm.Ring[fo].length; k++)
    {
     if (m_MandolinBarreChordDm.Ring[fo][k].Str == wstr && m_MandolinBarreChordDm.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_MandolinBarreChordDm.Pinky[fo].length; k++)
    {
     if (m_MandolinBarreChordDm.Pinky[fo][k].Str == wstr && m_MandolinBarreChordDm.Pinky[fo][k].Fret == fret)
       return "P";
    }
   for (k=0; k<m_MandolinBarreChordDm.NoPlay[fo].length; k++)
    {
     if (m_MandolinBarreChordDm.NoPlay[fo][k].Str == wstr && m_MandolinBarreChordDm.NoPlay[fo][k].Fret == fret)
       return "X";
    }
  }
 return "";
}

// Show Note gets the ShowNote property of the BarreIndex object for barre chord fingerings
// the Offset lookup system is the same as GenMandolinBarreStringElement above

function GenMandolinBarreShowNote(chord, offset, wstr, fret) // chord (index to m_arrChordPattern), offset c=0, string (low = 0), fret #
{ 
 // for barre need to not return fingerings for open A and open E
 if (chord == m_cpMajor)
  {
   fo = m_MandolinBarreChordD.Offsets[offset]; // if offset = 0, C, fo = 2
   for (k=0; k<m_MandolinBarreChordD.Index[fo].length; k++)
    {
     if (m_MandolinBarreChordD.Index[fo][k].Str == wstr && m_MandolinBarreChordD.Index[fo][k].Fret == fret)
       return m_MandolinBarreChordD.Index[fo][k].ShowNote;
    }
  }
 if (chord == m_cpMinor)
  {
   fo = m_MandolinBarreChordDm.Offsets[offset];
   for (k=0; k<m_MandolinBarreChordDm.Index[fo].length; k++)
    {
     if (m_MandolinBarreChordDm.Index[fo][k].Str == wstr && m_MandolinBarreChordDm.Index[fo][k].Fret == fret)
       return m_MandolinBarreChordDm.Index[fo][k].ShowNote;
    }
  }
 return 1;
}

// generate a TR html for a mandolin string for a specific chord

function GenMandolinString(chord, offset, wstr, key) // index to ChordPattern, offset C=0, string # low E is 0, Key object
{
 var midi;
 var barre, fb, barreShowNote;
 var html = "<tr>";
 var fret;
 var gradient;
 var sw = fretStartSize; // 40 pixels
 var inChord;
 var w;

 for (fret=0; fret<m_arrInstruments[m_Mandolin].Frets; fret++)
  {
   if (fret == 0) // before the nut
     w = fretBeforeNut;   // 25 pixels
   else  
     w = sw;
   html += "<td class='fretString'>";

   midi = m_arrMandolin[wstr][fret]; // get midi note of string and fret
   inChord = MidiNoteInChord(chord, offset, midi);
   fb = GenMandolinStringElement(chord, offset, wstr, fret);
   barre = GenMandolinBarreStringElement(chord, offset, wstr, fret);
   barreShowNote = GenMandolinBarreShowNote(chord, offset, wstr, fret);
   gradient = FigureOutGradient(chord, offset, midi);

   html += GenMandolinCell(w, fb, barre, midi, barreShowNote, key, gradient, inChord);
  
   html += "</td>";
   sw -=  fretDecrease; // 1 pixel
  }
 html += "</tr>";
 return html;
}

function GenMandolinStringScale(wstr, key) // index to ChordPattern, offset C=0, string # low E is 0, Key object
{
 var midi;
 var bg, fg;
 var sn;
 var html = "<tr>";
 var fret;
 var sw = fretStartSize; //vw units about 40 pixels on a 1920 display, this is the size of area between the nut and fret 1
 var w;

 for (fret=0; fret<m_arrInstruments[m_Mandolin].Frets; fret++)
  {
   midi = m_arrMandolin[wstr][fret]; // get midi note of string and fret
   
   sn = 0;
   for(i=0; i<key.Offsets.length; i++)
    {
     if (m_mapMidiNotes.get(midi).Offset == key.Offsets[i])
       sn = i+1;
    }

   if (sn > 0)
    {
     bg = m_arrGradientBlueGreen[sn-1];
     fg = "#000044";
    }
   else
    {
     bg = "#CCCCCC";
     fg = "white";
    }
   if (fret == 0)        // before the nut
     w = fretBeforeNut;  // 25 pixels
   else  
     w = sw;

   html += "<td class='fretString' style='color:" + fg + "; background-color:" + bg + ";'>";

   html += GenMandolinCellScale(w, midi, sn, key);
  
   html += "</td>";
   sw -= fretDecrease; // subtract about a pixel on 1920 monitor
  }
 html += "</tr>";
 return html;
}

function GenMandolinMarks()
{
 var html = "<tr>";
 var fret;
 var sw = fretMarkStart; // 30 pixels, have to slide this over a bit to line up the dots like a fretboard

 for (fret=0; fret<m_arrInstruments[m_Mandolin].Frets; fret++)
  {
   if (fret == 0) // before the nut
     w = fretMarkBeforeNut;   // 15 pixels
   else  
     w = sw;
   html += "<td class='fretMark' style='width:" + w.toString() + "vw;'>";
   if (fret == 0)
     html += "Nut";
   if (fret == 5 || fret ==7 || fret == 10 || fret == 15) 
     html += symDot;
   if (fret == 12)
     html += symDot + symDot;
   html += "</td>";
   sw -= fretDecrease;
  }

 html += "</tr>";
 return html;
}


// return HTML for a mandolin fret by string an fret #

function GenMandolinCell(width, open, barre, midiNote, barreShowNote, key, grad, inChord) // width is cell size, open & barre are fingering letter, barreShowNote is for index no play, key is Key object, 0 thru 5 gradient color of note based on step in chord
{
 var html;
 var note;
 var color;
 var midi;

 midi = m_mapMidiNotes.get(midiNote);
 
 if (key.LookUp[midi.Offset] >= 0)
   note = midi.MidiName(key);
 else 
   note = NoteText(midi.Offset) + "(" + midi.Octave.toString() + ")"; 

if (m_CurrentMandolinTuning == 0) // is it standard tuning?
  {
   if (open == "" && barre == "")
    {
     note = "";
    }
   else 
    {
     if (open == "X" || barre == "X")
       note = "";
     else 
      {
       if (barre == "I")
        {
         if (barreShowNote == 0)
           note = "";
        }
      }
    }
  }
 else // non standard tuning, just show notes that are in the chord
  {
   open = "";
   barre = "";
   if (inChord == false)
    {
     note = "";
    }   
  }

 if (note != "")
  {
   color = m_arrPastels[grad]; 
  }
 else
  {
   color = "#ffffff";
  }

 html = "<div class='fretCell' style='width:" + width.toString() + "vw; background-color:" + color + "'>";
 html += note;
 
 if (open != "")
   html += "<div class='fretCellLeft'>" + open + "</div>";

 if (barre != "")
   html += "<div class='fretCellRight'>" + barre + "</div>";

 html += "</div>";

 return html;
}

// return HTML for a string / fret cell for the scale fretboard

function GenMandolinCellScale(width, midiNote, scaleNum, key)
{
 var html;
 var note;

 if (key.LookUp[m_mapMidiNotes.get(midiNote).Offset] >= 0)
   note = m_mapMidiNotes.get(midiNote).MidiName(key);
 else 
   note = ""; 

 if (scaleNum == 0)
  {
   note = "";
  }

 html = "<div class='fretCell' style='width:" + width.toString() + "vw;'>";
 html += note;

 if (scaleNum > 0)
   html += "<div class='fretCellRight'>" + scaleNum.toString() + "</div>";

 html += "</div>";

 return html;
}

function GenMandolin(chord, offset, key) // chord pattern index, offset C=0, Key object
{
 var html;

 html = "<table>";

 html += GenMandolinString(chord, offset, 3, key);
 html += GenMandolinString(chord, offset, 2, key);
 html += GenMandolinString(chord, offset, 1, key);
 html += GenMandolinString(chord, offset, 0, key);
 html += GenMandolinMarks();

 html += "</table>";
  
 return html;
}

function GenMandolinScale(key)
{
 var html;

 html = "<table><tr><td><table><tr>" // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='scaleName' onclick='PlayKeyScale();'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrModes[m_CurrentMode].ModeName;
 html += " Scale";
 html += "</td>";

 html += GenScaleInfo(key);  // returns more TDs

 html += "</tr></table></tr></td><tr><td><table>";

 html += GenMandolinStringScale(3, key);
 html += GenMandolinStringScale(2, key);
 html += GenMandolinStringScale(1, key);
 html += GenMandolinStringScale(0, key);
 html += GenMandolinMarks();

 html += "</table></td></tr></table>";

 return html;
}

////////////////////////////////////////////////
//                 U k u l e l e     
////////////////////////////////////////////////

// generate ukulele fretboard
// returns a open chord fingering letter I,M,R,P or O, X based on string and fret
// m_arrChordPatterns has been prepared that contain the fingering

function GenUkuleleStringElement(chord, offset, wstr, fret) // chord = chord pattern index, offset c=0, wstr is string #, fret # nut is 0
{
 var i, k;

 for (i=0; i<m_arrChordPatterns[chord].PatternUkulele.length; i++) // go thru the placements
  {
   if (m_arrChordPatterns[chord].PatternUkulele[i].Offset == offset) // see if offset is present C = 0
    {
     for(k=0; k<m_arrChordPatterns[chord].PatternUkulele[i].Index.length; k++) // go thru Index finger list
      {
       if (m_arrChordPatterns[chord].PatternUkulele[i].Index[k].Str == wstr && m_arrChordPatterns[chord].PatternUkulele[i].Index[k].Fret == fret)
         return "I"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternUkulele[i].Middle.length; k++) // go thru middle finger list
      {
       if (m_arrChordPatterns[chord].PatternUkulele[i].Middle[k].Str == wstr && m_arrChordPatterns[chord].PatternUkulele[i].Middle[k].Fret == fret)
         return "M"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternUkulele[i].Ring.length; k++) // go thru ring finger list
      {
       if (m_arrChordPatterns[chord].PatternUkulele[i].Ring[k].Str == wstr && m_arrChordPatterns[chord].PatternUkulele[i].Ring[k].Fret == fret)
         return "R"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternUkulele[i].Pinky.length; k++) // go thru pinky finger list
      {
       if (m_arrChordPatterns[chord].PatternUkulele[i].Pinky[k].Str == wstr && m_arrChordPatterns[chord].PatternUkulele[i].Pinky[k].Fret == fret)
         return "P"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternUkulele[i].Open.length; k++) // go thru open string list
      {
       if (m_arrChordPatterns[chord].PatternUkulele[i].Open[k].Str == wstr && m_arrChordPatterns[chord].PatternUkulele[i].Open[k].Fret == fret)
         return "O"; 
      }
     for(k=0; k<m_arrChordPatterns[chord].PatternUkulele[i].NoPlay.length; k++) // go thru no play finger list
      {
       if (m_arrChordPatterns[chord].PatternUkulele[i].NoPlay[k].Str == wstr && m_arrChordPatterns[chord].PatternUkulele[i].NoPlay[k].Fret == fret)
         return "X"; 
      }
    }
  }
 return "";
}

// return barre chord fingering I,M,R,P or X based on string and fret
// each barre pattern, E and A types were prepared.
// the Offsets array for each contains the offset to the barre pattern fingering array
// the offset gives the location of the barre chord for the passed offset. For the A and Am pattern C = 0 would return 2 which is the A pattern up the 3rd fret.
// the reason C is not 3 is because the open A is not included in the fingering, only barre chords are present.  

function GenUkuleleBarreStringElement(chord, offset, wstr, fret) // ChordPatteren index, offset C=0, String # (low E is 0), fret # (nut is 0)
{ 
 // for barre need to not return fingerings for open A and open E
 if (chord == m_cpMajor)
  {
   fo = m_GuitarBarreChordA.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordA.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Index[fo][k].Str == wstr && m_GuitarBarreChordA.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordA.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Middle[fo][k].Str == wstr && m_GuitarBarreChordA.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordA.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Ring[fo][k].Str == wstr && m_GuitarBarreChordA.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordA.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Pinky[fo][k].Str == wstr && m_GuitarBarreChordA.Pinky[fo][k].Fret == fret)
       return "P";
    }
   for (k=0; k<m_GuitarBarreChordA.NoPlay[fo].length; k++)
    {
     if (m_GuitarBarreChordA.NoPlay[fo][k].Str == wstr && m_GuitarBarreChordA.NoPlay[fo][k].Fret == fret)
       return "X";
    }
   fo = m_GuitarBarreChordE.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordE.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Index[fo][k].Str == wstr && m_GuitarBarreChordE.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordE.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Middle[fo][k].Str == wstr && m_GuitarBarreChordE.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordE.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Ring[fo][k].Str == wstr && m_GuitarBarreChordE.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordE.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Pinky[fo][k].Str == wstr && m_GuitarBarreChordE.Pinky[fo][k].Fret == fret)
       return "P";
    }
  }
 if (chord == m_cpMinor)
  {
   fo = m_GuitarBarreChordAm.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordAm.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Index[fo][k].Str == wstr && m_GuitarBarreChordAm.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordAm.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Middle[fo][k].Str == wstr && m_GuitarBarreChordAm.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordAm.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Ring[fo][k].Str == wstr && m_GuitarBarreChordAm.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordAm.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Pinky[fo][k].Str == wstr && m_GuitarBarreChordAm.Pinky[fo][k].Fret == fret)
       return "P";
    }
   for (k=0; k<m_GuitarBarreChordAm.NoPlay[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.NoPlay[fo][k].Str == wstr && m_GuitarBarreChordAm.NoPlay[fo][k].Fret == fret)
       return "X";
    }
   fo = m_GuitarBarreChordEm.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordEm.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Index[fo][k].Str == wstr && m_GuitarBarreChordEm.Index[fo][k].Fret == fret)
       return "I";
    }
   for (k=0; k<m_GuitarBarreChordEm.Middle[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Middle[fo][k].Str == wstr && m_GuitarBarreChordEm.Middle[fo][k].Fret == fret)
       return "M";
    }
   for (k=0; k<m_GuitarBarreChordEm.Ring[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Ring[fo][k].Str == wstr && m_GuitarBarreChordEm.Ring[fo][k].Fret == fret)
       return "R";
    }
   for (k=0; k<m_GuitarBarreChordEm.Pinky[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Pinky[fo][k].Str == wstr && m_GuitarBarreChordEm.Pinky[fo][k].Fret == fret)
       return "P";
    }
  }
 return "";
}

// Show Note gets the ShowNote property of the BarreIndex object for barre chord fingerings
// the Offset lookup system is the same as GenGuitarBarreStringElement above

function GenUkuleleBarreShowNote(chord, offset, wstr, fret) // chord (index to m_arrChordPattern), offset c=0, string (low = 0), fret #
{ 
 // for barre need to not return fingerings for open A and open E
 if (chord == m_cpMajor)
  {
   fo = m_GuitarBarreChordA.Offsets[offset]; // if offset = 0, C, fo = 2
   for (k=0; k<m_GuitarBarreChordA.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordA.Index[fo][k].Str == wstr && m_GuitarBarreChordA.Index[fo][k].Fret == fret)
       return m_GuitarBarreChordA.Index[fo][k].ShowNote;
    }
   fo = m_GuitarBarreChordE.Offsets[offset];  // if offset = 0, c, fo = 7
   for (k=0; k<m_GuitarBarreChordE.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordE.Index[fo][k].Str == wstr && m_GuitarBarreChordE.Index[fo][k].Fret == fret)
       return m_GuitarBarreChordE.Index[fo][k].ShowNote;
    }
  }
 if (chord == m_cpMinor)
  {
   fo = m_GuitarBarreChordAm.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordAm.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordAm.Index[fo][k].Str == wstr && m_GuitarBarreChordAm.Index[fo][k].Fret == fret)
       return m_GuitarBarreChordAm.Index[fo][k].ShowNote;
    }
   fo = m_GuitarBarreChordEm.Offsets[offset];
   for (k=0; k<m_GuitarBarreChordEm.Index[fo].length; k++)
    {
     if (m_GuitarBarreChordEm.Index[fo][k].Str == wstr && m_GuitarBarreChordEm.Index[fo][k].Fret == fret)
       return m_GuitarBarreChordEm.Index[fo][k].ShowNote;
    }
  }
 return 1;
}

// generate a TR html for a guitar string for a specific chord

function GenUkuleleString(chord, offset, wstr, key) // index to ChordPattern, offset C=0, string # low E is 0, Key object
{
 var midi;
 var barre, fb, barreShowNote;
 var html = "<tr>";
 var fret;
 var gradient;
 var sw = fretStartSize; // 40 pixels
 var inChord;
 var w;

 for (fret=0; fret<m_arrInstruments[m_Ukulele].Frets; fret++)
  {
   if (fret == 0) // before the nut
     w = fretBeforeNut;   // 25 pixels
   else  
     w = sw;
   html += "<td class='fretString'>";

   midi = m_arrUkulele[wstr][fret]; // get midi note of string and fret
   inChord = MidiNoteInChord(chord, offset, midi);
   fb = GenUkuleleStringElement(chord, offset, wstr, fret);
   barre = GenUkuleleBarreStringElement(chord, offset, wstr, fret);
   barreShowNote = GenUkuleleBarreShowNote(chord, offset, wstr, fret);
   gradient = FigureOutGradient(chord, offset, midi);

   html += GenUkuleleCell(w, fb, barre, midi, barreShowNote, key, gradient, inChord);
  
   html += "</td>";
   sw -=  fretDecrease; // 1 pixel
  }
 html += "</tr>";
 return html;
}

function GenUkuleleStringScale(wstr, key) // index to ChordPattern, offset C=0, string # low E is 0, Key object
{
 var midi;
 var bg, fg;
 var sn;
 var html = "<tr>";
 var fret;
 var sw = fretStartSize; //vw units about 40 pixels on a 1920 display, this is the size of area between the nut and fret 1
 var w;

 for (fret=0; fret<m_arrInstruments[m_Ukulele].Frets; fret++)
  {
   midi = m_arrUkulele[wstr][fret]; // get midi note of string and fret
   
   sn = 0;
   for(i=0; i<key.Offsets.length; i++)
    {
     if (m_mapMidiNotes.get(midi).Offset == key.Offsets[i])
       sn = i+1;
    }

   if (sn > 0)
    {
     bg = m_arrGradientBlueGreen[sn-1];
     fg = "#000044";
    }
   else
    {
     bg = "#CCCCCC";
     fg = "white";
    }
   if (fret == 0)        // before the nut
     w = fretBeforeNut;  // 25 pixels
   else  
     w = sw;

   html += "<td class='fretString' style='color:" + fg + "; background-color:" + bg + ";'>";

   html += GenUkuleleCellScale(w, midi, sn, key);
  
   html += "</td>";
   sw -= fretDecrease; // subtract about a pixel on 1920 monitor
  }
 html += "</tr>";
 return html;
}

function GenUkuleleMarks()
{
 var html = "<tr>";
 var fret;
 var sw = fretMarkStart; // 30 pixels, have to slide this over a bit to line up the dots like a fretboard

 for (fret=0; fret<m_arrInstruments[m_Ukulele].Frets; fret++)
  {
   if (fret == 0) // before the nut
     w = fretMarkBeforeNut;   // 15 pixels
   else  
     w = sw;
   html += "<td class='fretMark' style='width:" + w.toString() + "vw;'>";
   if (fret == 0)
     html += "Nut";
   if (fret == 3 || fret == 5 || fret ==7 || fret == 10) 
     html += symDot;
   if (fret == 12)
     html += symDot + symDot;
   html += "</td>";
   sw -= fretDecrease;
  }

 html += "</tr>";
 return html;
}

// return HTML for a ukulele fret by string an fret #

function GenUkuleleCell(width, open, barre, midiNote, barreShowNote, key, grad, inChord) // width is cell size, open & barre are fingering letter, barreShowNote is for index no play, key is Key object, 0 thru 5 gradient color of note based on step in chord
{
 var html;
 var note;
 var color;
 var midi;

 midi = m_mapMidiNotes.get(midiNote);
 
 if (key.LookUp[midi.Offset] >= 0)
   note = midi.MidiName(key);
 else 
   note = NoteText(midi.Offset) + "(" + midi.Octave.toString() + ")"; 

if (m_CurrentUkuleleTuning == 0) // is it standard tuning?
  {
   if (open == "" && barre == "")
    {
     note = "";
    }
   else 
    {
     if (open == "X" || barre == "X")
       note = "";
     else 
      {
       if (barre == "I")
        {
         if (barreShowNote == 0)
           note = "";
        }
      }
    }
  }
 else // non standard tuning, just show notes that are in the chord
  {
   open = "";
   barre = "";
   if (inChord == false)
    {
     note = "";
    }   
  }

 if (note != "")
  {
   color = m_arrPastels[grad]; 
  }
 else
  {
   color = "#ffffff";
  }

 html = "<div class='fretCell' style='width:" + width.toString() + "vw; background-color:" + color + "'>";
 html += note;
 
 if (open != "")
   html += "<div class='fretCellLeft'>" + open + "</div>";

 if (barre != "")
   html += "<div class='fretCellRight'>" + barre + "</div>";

 html += "</div>";

 return html;
}

// return HTML for a string / fret cell for the scale fretboard

function GenUkuleleCellScale(width, midiNote, scaleNum, key)
{
 var html;
 var note;

 if (key.LookUp[m_mapMidiNotes.get(midiNote).Offset] >= 0)
   note = m_mapMidiNotes.get(midiNote).MidiName(key);
 else 
   note = ""; 

 if (scaleNum == 0)
  {
   note = "";
  }

 html = "<div class='fretCell' style='width:" + width.toString() + "vw;'>";
 html += note;

 if (scaleNum > 0)
   html += "<div class='fretCellRight'>" + scaleNum.toString() + "</div>";

 html += "</div>";

 return html;
}

function GenUkulele(chord, offset, key) // chord pattern index, offset C=0, Key object
{
 var html;

 html = "<table>";

 html += GenUkuleleString(chord, offset, 3, key);
 html += GenUkuleleString(chord, offset, 2, key);
 html += GenUkuleleString(chord, offset, 1, key);
 html += GenUkuleleString(chord, offset, 0, key);
 html += GenUkuleleMarks();

 html += "</table>";
  
 return html;
}

function GenUkuleleScale(key)
{
 var html;

 html = "<table><tr><td><table><tr>" // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='scaleName' onclick='PlayKeyScale();'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrModes[m_CurrentMode].ModeName;
 html += " Scale";
 html += "</td>";

 html += GenScaleInfo(key);  // returns more TDs

 html += "</tr></table></tr></td><tr><td><table>";

 html += GenUkuleleStringScale(3, key);
 html += GenUkuleleStringScale(2, key);
 html += GenUkuleleStringScale(1, key);
 html += GenUkuleleStringScale(0, key);

 html += GenUkuleleMarks();

 html += "</table></td></tr></table>";

 return html;
}

////////////////////////////////////////////////
//            K e y b o a r d     
////////////////////////////////////////////////

function GenPianoChordNote(cssName, key, midiNote, arrNotes, arrColor)
{
 var html;
 var chordSeq;
 var fg
 var bg;
 var i;
 var note;

 chordSeq = -1;
 for (i=0; i<arrNotes.length; i++)
  {
   if (midiNote == arrNotes[i])
     chordSeq = i;
  }

 if (chordSeq >=0)
  {
   bg = arrColor[chordSeq];
   fg = "black";

   html = "<div class='" + cssName + "' style='color:" + fg + "; background-color:" + bg + ";'>";
   
   note = m_mapMidiNotes.get(midiNote).Name(key);
   i = note.indexOf("/");
   if (i>0)
     note = note.substring(0,i) + "<br>" + note.substring(i+1);

   html += note;
   html += "</div>";
  }
 else
  {
   html = ""; // don't show a note
  }
 return html;
}

//   c#  d#     f#  g#  a#    c#   d#     f#  g#  a#
// c   d   e  f   g   a   b  c   d   e  f   g   a   b     
// 0 1 2 3 4 5  6 7 8 9 1 1  1 1 1 1 1  1 1 1 2 2 2 2
//                      0 1  2 3 4 5 6  7 8 9 0 1 2 3

function GenPianoChord(octaves, chord, offset, key) // return divs of piano keys.  # of octaves to show, index to chord pattern array, root note offset, key object
{                                                   
 var pat = m_arrChordPatterns[chord];
 var html;
 var k;     
 var x;     // x position of each octave set of keys
 var o;
 var wMidi, sMidi, midi;
 var arrChordNotes = new Array();
 var found;

 wMidi = 48; //  c3 - starting note

 sMidi = wMidi + m_Key.Offset;  // step up to key's starting note, 

 found = false;
 for(i=0; i<m_Key.Offsets.length; i++)
  {
   if (m_Key.Offsets[i] == offset) // go thru the key's offsets until the current chord root note offset is found
     found = true;
   if (found == false)
     sMidi += m_arrModes[m_CurrentMode].Sequences[i]; // bump the midi note # up until the offset is found
  }

 // sMidi will be the chord's root note up from the mode's starting chord root

 for(i=0; i<pat.Pitches.length; i++)
  {
   arrChordNotes[i] = sMidi + pat.Pitches[i];
  }

 html = "<div style='position:relative; width:" + octaves * pianoWhiteWidth * 7 + "vw; height:" + pianoWhiteHeight + "vw;'>";

 x = 0;  // starting x position

 for (o=0; o<octaves; o++)
  {
   off = 0;             // note offset, c = 0
   w = x;               // div x position
   midi = wMidi;
   for (k=0; k<7; k++)  // 7 white keys from C to B
    {
     html += "<div class='pianoWhite' style='left:" + w.toString() + "vw;' onclick='PlaySingleNote(" + midi.toString() +");'>";
     html += GenPianoChordNote("pianoWhiteText", key, midi, arrChordNotes, m_arrPastels);
     html += "</div>";
     if (k==2 || k==6)  // E or B  key ??
      {
       midi += 1; // next white key
      }
     else
      { 
       midi += 2; // rest of the white keys are up 2
      }
     w += pianoWhiteWidth;
    }
   w = x + pianoWhiteWidth - (pianoBlackWidth / 2);  // center black keys in middle of 1st white key
   midi = wMidi + 1;  // starting midi note of black keys
   for (k=0; k<5; k++) // 5 black keys
    {
     html += "<div class='pianoBlack' style='left:" + w.toString() + "vw;' onclick='PlaySingleNote(" + midi.toString() +");'>";
     html += GenPianoChordNote("pianoBlackText", key, midi, arrChordNotes, m_arrPastels);
     html += "</div>"; 
     if (k==1 || k==4) // is the next key an f# or c#
      {
       w += pianoWhiteWidth * 2;  // move next f# or c# over 2 white key widths
       midi += 3;                   // note offset is bumped 3
      }
     else
      {
       w += pianoWhiteWidth;   // these keys are next to each other  
       midi += 2;               
      }
    }
   x += pianoWhiteWidth * 7; // next octive set x location
   wMidi += 12;
  }
 
 html += "</div>";

 return html;
}

function GenPianoScaleKeys(octaves, key, arrScaleNotes) // return divs of piano keys. ocatives is number of octaves to draw
{
 var html;
 var k;     
 var x;     // x position of each octave set of keys
 var o;
 var wMidi, midi;

 wMidi = 48; // c3 - starting note

 html = "<div style='position:relative; width:" + octaves * pianoWhiteWidth * 7 + "vw; height:" + pianoWhiteHeight + "vw;'>";

 x = 0;  // starting x position

 for (o=0; o<octaves; o++)
  {
   off = 0;             // note offset, c = 0
   w = x;               // div x position
   midi = wMidi;
   for (k=0; k<7; k++)  // 7 white keys from C to B
    {
     html += "<div class='pianoWhite' style='left:" + w.toString() + "vw;' onclick='PlaySingleNote(" + midi.toString() +");'>";
     html += GenPianoChordNote("pianoWhiteText", key, midi, arrScaleNotes, m_arrGradientBlueGreen);
     html += "</div>";
     if (k==2 || k==6)  // E or B  key ??
      {
       midi += 1; // next white key
      }
     else
      { 
       midi += 2; // rest of the white keys are up 2
      }
     w += pianoWhiteWidth;
    }
   w = x + pianoWhiteWidth - (pianoBlackWidth / 2);  // center black keys in middle of 1st white key
   midi = wMidi + 1;  // starting midi note of black keys
   for (k=0; k<5; k++) // 5 black keys
    {
     html += "<div class='pianoBlack' style='left:" + w.toString() + "vw;' onclick='PlaySingleNote(" + midi.toString() +");'>";
     html += GenPianoChordNote("pianoBlackText", key, midi, arrScaleNotes, m_arrGradientBlueGreen);
     html += "</div>"; 
     if (k==1 || k==4) // is the next key an f# or c#
      {
       w += pianoWhiteWidth * 2;  // move next f# or c# over 2 white key widths
       midi += 3;                 // note offset is bumped 3
      }
     else
      {
       w += pianoWhiteWidth;   // these keys are next to each other  
       midi += 2;               
      }
    }
   x += pianoWhiteWidth * 7; // next octive set x location
   wMidi += 12;
  }
 
 html += "</div>";

 return html;
}

function GenPianoScale(key, mode)
{
 var html;
 var arrScaleNotes = new Array();
 var wMidi, midi;
 var i;

 wMidi = 48;                 // keyboard's starting midi note c3
 midi = wMidi + key.Offset;  // scale's starting midi note

 for (i=0; i<m_arrModes[mode].Sequences.length; i++)
  {
   arrScaleNotes[i] = midi;
   midi += m_arrModes[mode].Sequences[i];
  }

 html = "<table><tr><td><table><tr>" // holds scale name and table containing notes in scale then the fretboard table

 html += "<td class='scaleName' onclick='PlayKeyScale();'>";
 html += key.OffsetNote(key.Offsets[0]).Text;
 html += " ";
 html += m_arrModes[m_CurrentMode].ModeName;
 html += " Scale";
 html += "</td>";

 html += GenScaleInfo(key);

 html += "</tr></table></tr></td><tr><td>";

 html += GenPianoScaleKeys(2, key, arrScaleNotes, m_arrGradientBlueGreen);

 html += "</td></tr></table>";

 return html; 
}

//////////////////////////////////////////////
//            Load Combo Boxes
//////////////////////////////////////////////

function dynaInstLoader(cboName)
{
 document.getElementById(cboName).options.length=0;
 for (i=0;i<m_arrInstruments.length;i++)
  {
   oOption=document.createElement("OPTION");
   oOption.style.backgroundColor="white";
   oOption.text=m_arrInstruments[i].InstrumentName;
   oOption.value=m_arrInstruments[i].ID;
   document.getElementById(cboName).options.add(oOption);
  } 
 m_CurrentInstrument = m_arrInstruments[0].ID;
}

function dynaModesLoaderTH(cboName)
{
 var i,oOption;
 
 document.getElementById(cboName).options.length=0;
 
 for (i=0;i<m_arrModes.length;i++)
  {
   if (m_arrModes[i].KeyList.length > 0)  // only add modes that I've filled out the key list
    {
     oOption=document.createElement("OPTION");
     oOption.style.backgroundColor=m_arrModes[i].Background;
     oOption.text=m_arrModes[i].ModeName;
     oOption.value=m_arrModes[i].ID;
     document.getElementById(cboName).options.add(oOption);
    }
  } 
 eventcboModesTH_Change();
}

function dynaModesLoaderChord(cboName)
{
 var i,oOption;
 
 document.getElementById(cboName).options.length=0;
 
 for (i=0;i<m_arrModes.length;i++)
  {
   if (m_arrModes[i].KeyList.length > 0)  // only add modes that I've filled out the key list
    {
     oOption=document.createElement("OPTION");
     oOption.style.backgroundColor=m_arrModes[i].Background;
     oOption.text=m_arrModes[i].ModeName;
     oOption.value=m_arrModes[i].ID;
     document.getElementById(cboName).options.add(oOption);
    }
  } 
 eventcboModesChord_Change();
}

function dynaModesLoaderScale(cboName)
{
 var i,oOption;
 
 document.getElementById(cboName).options.length=0;
 
 for (i=0;i<m_arrModes.length;i++)
  {
   if (m_arrModes[i].KeyList.length > 0)  // only add modes that I've filled out the key list
    {
     oOption=document.createElement("OPTION");
     oOption.style.backgroundColor=m_arrModes[i].Background;
     oOption.text=m_arrModes[i].ModeName;
     oOption.value=m_arrModes[i].ID;
     document.getElementById(cboName).options.add(oOption);
    }
  } 
 eventcboModesScale_Change();
}

function dynaPatternsLoaderChord(cboName)
{
 var s,i,oOption;
 
 document.getElementById(cboName).options.length=0;
 
 for (i=0;i<m_arrChordPatterns.length;i++)
  {
   oOption=document.createElement("OPTION");
   s=m_arrChordPatterns[i].Name+" ";
   s+="("+m_arrChordPatterns[i].Formula+")";
   oOption.text=s;
   oOption.value=i;

   document.getElementById(cboName).options.add(oOption);
  } 
 eventcboPatternsChord_Change();
}

function dynaCapoLoader()
{
 var i, s, oOption;

 for(i=0;i<m_arrInstruments[m_Guitar].Frets; i++)
  {
   oOption=document.createElement("OPTION");
   if (i==0)
     s="None";
   else
     s="Fret " + i.toString();
   oOption.text=s;
   oOption.value=i;   
   document.getElementById("cboGuitarCapo").options.add(oOption);
  }
 for(i=0;i<m_arrInstruments[m_Bass].Frets; i++)
  {
   oOption=document.createElement("OPTION");
   if (i==0)
     s="None";
   else
     s="Fret " + i.toString();
   oOption.text=s;
   oOption.value=i;   
   document.getElementById("cboBassCapo").options.add(oOption);
  }
 for(i=0;i<m_arrInstruments[m_Mandolin].Frets; i++)
  {
   oOption=document.createElement("OPTION");
   if (i==0)
     s="None";
   else
     s="Fret " + i.toString();
   oOption.text=s;
   oOption.value=i;   
   document.getElementById("cboMandolinCapo").options.add(oOption);
  }
 for(i=0;i<m_arrInstruments[m_Ukulele].Frets; i++)
  {
   oOption=document.createElement("OPTION");
   if (i==0)
     s="None";
   else
     s="Fret " + i.toString();
   oOption.text=s;
   oOption.value=i;   
   document.getElementById("cboUkuleleCapo").options.add(oOption);
  }
}

function dynaTuneLoader()
{
 var i, oOption;

 for (i=0; i<m_arrInstruments[m_Guitar].Tunings.length; i++)
  {
   oOption=document.createElement("OPTION");
   oOption.text= m_arrInstruments[m_Guitar].Tunings[i].TuningName;
   oOption.value=i;   
   document.getElementById("cboGuitarTune").options.add(oOption);
  }

 for (i=0; i<m_arrInstruments[m_Bass].Tunings.length; i++)
  {
   oOption=document.createElement("OPTION");
   oOption.text= m_arrInstruments[m_Bass].Tunings[i].TuningName;
   oOption.value=i;   
   document.getElementById("cboBassTune").options.add(oOption);
  }

 for (i=0; i<m_arrInstruments[m_Mandolin].Tunings.length; i++)
  {
   oOption=document.createElement("OPTION");
   oOption.text= m_arrInstruments[m_Mandolin].Tunings[i].TuningName;
   oOption.value=i;   
   document.getElementById("cboMandolinTune").options.add(oOption);
  }

 for (i=0; i<m_arrInstruments[m_Ukulele].Tunings.length; i++)
  {
   oOption=document.createElement("OPTION");
   oOption.text= m_arrInstruments[m_Ukulele].Tunings[i].TuningName;
   oOption.value=i;   
   document.getElementById("cboUkuleleTune").options.add(oOption);
  }
}

////////////////////////////////////////////////
//               E v e n t s 
////////////////////////////////////////////////

function eventRadInstrument(inst)
{
 m_CurrentInstrument = inst;
}

function eventcboKeysTH_Change()
{
 m_CurrentKey = parseInt(document.getElementById("cboKeysTH").options[document.getElementById("cboKeysTH").selectedIndex].value);

 m_Key = new Key(m_CurrentMode, m_arrModes[m_CurrentMode].KeyList[m_CurrentKey]);

 showChords();
 showScale();
 showModeChords();
}

function eventcboModesTH_Change()
{
 var i;

 m_CurrentMode = parseInt(document.getElementById("cboModesTH").options[document.getElementById("cboModesTH").selectedIndex].value);

 document.getElementById("cboKeysTH").options.length = 0;

 for (i=0;i<m_arrModes[m_CurrentMode].KeyList.length;i++)
  {
   oOption=document.createElement("OPTION");
   oOption.style.backgroundColor=m_arrModes[m_CurrentMode].Background;
   oOption.text="Key of " + m_arrModes[m_CurrentMode].KeyList[i].Text;
   oOption.value=i;
   document.getElementById("cboKeysTH").options.add(oOption);
  }

 m_CurrentKey = 0;
 m_Key = new Key(m_CurrentMode, m_arrModes[m_CurrentMode].KeyList[m_CurrentKey]);
 showChords();
 showScale();
 showModeChords();
}

function eventcboModesChord_Change()
{
 var i;

 m_CurrentMode = parseInt(document.getElementById("cboModesChord").options[document.getElementById("cboModesChord").selectedIndex].value);

 document.getElementById("cboKeysChord").options.length = 0;

 for (i=0;i<m_arrModes[m_CurrentMode].KeyList.length;i++)
  {
   oOption=document.createElement("OPTION");
   oOption.style.backgroundColor=m_arrModes[m_CurrentMode].Background;
   oOption.text="Key of " + m_arrModes[m_CurrentMode].KeyList[i].Text;
   oOption.value=i;
   document.getElementById("cboKeysChord").options.add(oOption);
  }

 eventcboKeysChord_Change();
}

function eventcboModesScale_Change()
{
 var i;

 m_CurrentMode = parseInt(document.getElementById("cboModesScale").options[document.getElementById("cboModesScale").selectedIndex].value);

 document.getElementById("cboKeysScale").options.length = 0;

 for (i=0;i<m_arrModes[m_CurrentMode].KeyList.length;i++)
  {
   oOption=document.createElement("OPTION");
   oOption.style.backgroundColor=m_arrModes[m_CurrentMode].Background;
   oOption.text="Key of " + m_arrModes[m_CurrentMode].KeyList[i].Text;
   oOption.value=i;
   document.getElementById("cboKeysScale").options.add(oOption);
  }

 eventcboKeysScale_Change();
}


function eventcboKeysChord_Change()
{
 var html, i;

 m_CurrentKey = parseInt(document.getElementById("cboKeysChord").options[document.getElementById("cboKeysChord").selectedIndex].value);

 m_Key = new Key(m_CurrentMode, m_arrModes[m_CurrentMode].KeyList[m_CurrentKey]);

 html = "<table class='tableChordsRoot'><tr>"; 

 for (i=0;i<m_Key.Notes.length;i++)
  {
   html += "<td class='tdChordsRoot' onclick='eventTDChordRootNote_Click(" + i + ");'>";
   html += m_Key.Notes[i].Text;
   html += "</td>";
  }

 html += "</tr></table>";
 
 document.getElementById("tdChordRoots").innerHTML = html;
 
}

function eventcboKeysScale_Change()
{
 m_CurrentKey = parseInt(document.getElementById("cboKeysScale").options[document.getElementById("cboKeysScale").selectedIndex].value);

 m_Key = new Key(m_CurrentMode, m_arrModes[m_CurrentMode].KeyList[m_CurrentKey]);
}

function eventcboPatternsChord_Change()
{
 m_CurrentChordPattern =  parseInt(document.getElementById("cboPatternsChord").options[document.getElementById("cboPatternsChord").selectedIndex].value);
}

function eventTDChordRootNote_Click(keyNdx)
{
 var html, i, k, r;
 var outofkey, off;

 m_CurrentChordRoot = m_Key.Notes[keyNdx];  // m_CurrentChordRoot is a Note object

 html = "<table class='tableDlgPattern'>";
 html += "<tr>";
 r = 0;
 for (i=0; i<m_arrChordPatterns.length; i++)
  {
   outofkey = false;  // see if this chord pattern results in notes that would be out of key
   for (k=0; k<m_arrChordPatterns[i].Pitches.length; k++)
    {
     off = m_CurrentChordRoot.Offset + m_arrChordPatterns[i].Pitches[k];
     if (off >= 12)
       off -= 12;
     if (m_Key.OffsetNote(off) == null) // see if the note is out of key
       outofkey = true;
    }      
   if (r==4)
    {
     if (i>0)
       html += "</tr>";
     html += "<tr>";
     r = 0;
    }
   html += "<td class='tdDlgPattern' ";
   if (outofkey == true)
     html += "title='This chord would be out of key' ";
   html += "onclick='eventDialogChordPattern_Click(" + i + ");'>";
   html += "<span class='spanPatInKey' onclick='PlayChord(" + i.toString() + ", " + m_CurrentChordRoot.Offset.toString() + "); event.stopPropagation();' ";
   if (outofkey == true)
     html += "style='color:red;'>" + symNot + "</span> &nbsp; ";
   else
     html += "style='color:green;'>" + symNote + "</span> &nbsp; ";
   html += m_arrChordPatterns[i].Name;
   html += "</td>";
   r++;
  }

 if (r==4)
  html += "<tr>";
 html += "<td class='tdDlgPattern' onclick='eventDialogChordPattern_Click(-1);'>";
 html += "Cancel";
 html += "</td>";
 html += "</tr>";
 html += "</table>";

 document.getElementById("divDialog").innerHTML = html;
 document.getElementById("divDialogBase").style.display = "block";
}

function eventDialogChordPattern_Click(patternNdx)
{
 var html, table, row, td, cn;
 
 document.getElementById("divDialogBase").style.display = "none";
 document.getElementById("divDialog").innerHTML = "";

 if (patternNdx < 0) // cancel?
   return;

 table = document.getElementById("tableChords");

 row = table.insertRow(table.rows.length);
 
 td = row.insertCell(0);

 cn = m_CurrentChordRoot.Offset;

 html = "<table><tr><td class='tdSideChord'>";
 html += GenChordInfo(patternNdx, cn, m_Key);
 html += "</td><td>";

 switch(m_CurrentInstrument)
  {
   case m_Guitar:   html += GenGuitar(patternNdx, cn, m_Key);   break;
   case m_Bass:     html += GenBass(patternNdx, cn, m_Key);     break;
   case m_Mandolin: html += GenMandolin(patternNdx, cn, m_Key); break;
   case m_Ukulele:  html += GenUkulele(patternNdx, cn, m_Key);  break;
   case m_Keyboard: html += GenPianoChord(3, patternNdx, cn, m_Key); break; 
  }

 html += "</td></tr></table>";

 td.innerHTML = html;
}

function eventBtnChordClear_Click()
{
 var table = document.getElementById("tableChords");

 table.innerHTML = "";
}

function eventBtnScaleAdd_Click()
{
 var html, table;

 table = document.getElementById("tableScales");

 row = table.insertRow(table.rows.length);
 
 td = row.insertCell(0);

 cn = m_CurrentChordRoot.Offset;

 html = "<table><tr><td class='tdScaleInst'>";

 switch(m_CurrentInstrument)
  {
   case m_Guitar:   html += GenGuitarScale(m_Key);   break;
   case m_Bass:     html += GenBassScale(m_Key);     break;
   case m_Mandolin: html += GenMandolinScale(m_Key); break;
   case m_Ukulele:  html += GenUkuleleScale(m_Key);  break;
   case m_Keyboard: html += GenPianoScale(m_Key, m_CurrentMode); break; 
  }

 html += "</td></tr></table>";

 td.innerHTML = html;

}


function eventBtnScaleClear_Click()
{
 var table = document.getElementById("tableScales");

 table.innerHTML = "";
}

function eventcboGuitarCapo_Change()
{
 m_CurrentGuitarCapo =  parseInt(document.getElementById("cboGuitarCapo").options[document.getElementById("cboGuitarCapo").selectedIndex].value);
}

function eventcboBassCapo_Change()
{
 m_CurrentBassCapo =  parseInt(document.getElementById("cboBassCapo").options[document.getElementById("cboBassCapo").selectedIndex].value);
}

function eventcboMandolinCapo_Change()
{
 m_CurrentMandolinCapo =  parseInt(document.getElementById("cboMandolinCapo").options[document.getElementById("cboMandolinCapo").selectedIndex].value);
}

function eventcboUkuleleCapo_Change()
{
 m_CurrentUkuleleCapo =  parseInt(document.getElementById("cboUkuleleCapo").options[document.getElementById("cboUkuleleCapo").selectedIndex].value);
}

function eventcboGuitarTune_Change()
{
 m_CurrentGuitarTuning =  parseInt(document.getElementById("cboGuitarTune").options[document.getElementById("cboGuitarTune").selectedIndex].value);
 makeGuitar();
}

function eventcboBassTune_Change()
{
 m_CurrentBassTuning =  parseInt(document.getElementById("cboBassTune").options[document.getElementById("cboBassTune").selectedIndex].value);
 makeBass();
}

function eventcboMandolinTune_Change()
{
 m_CurrentMandolinTuning =  parseInt(document.getElementById("cboMandolinTune").options[document.getElementById("cboMandolinTune").selectedIndex].value);
 makeMandolin();
}

function eventcboUkuleleTune_Change()
{
 m_CurrentUkuleleTuning =  parseInt(document.getElementById("cboUkuleleTune").options[document.getElementById("cboUkuleleTune").selectedIndex].value);
 makeUkulele();
}

////////////////////////////////////////////////
//               S h o w   
////////////////////////////////////////////////

// high level show mode chords, instrument chords & instrument scales

function showChords()
{
 var pattern;
 var i;
 var cn;

 if (m_CurrentKey == -1 || m_CurrentMode == -1)
  {
   for (i=0; i<7; i++)
    {
     document.getElementById("tdChord" + i.toString()).innerHTML="";
    }
   return;
  }

 cn = m_Key.Offset;

 for (i=0; i<7; i++)
  {
   pattern = m_arrModes[m_CurrentMode].ChordType[i];
   document.getElementById('tdChord' + i.toString()).innerHTML = GenChordInfo(pattern, cn, m_Key);
   switch(m_CurrentInstrument)
    {
     case m_Guitar:   s = GenGuitar(pattern, cn, m_Key);   break;
     case m_Bass:     s = GenBass(pattern, cn, m_Key);     break;
     case m_Mandolin: s = GenMandolin(pattern, cn, m_Key); break;
     case m_Ukulele:  s = GenUkulele(pattern, cn, m_Key);  break;
     case m_Keyboard: s = GenPianoChord(3, pattern, cn, m_Key); break; 
    }
   document.getElementById('tdChordInst' + i.toString()).innerHTML = s;
   cn += m_arrModes[m_CurrentMode].Sequences[i];
   if (cn >= 12)
     cn -= 12;
  }

}

function showScale()
{
 var s;

 if (m_CurrentKey == -1 || m_CurrentMode == -1)
  {
   document.getElementById("tdScaleInst").innerHTML="";
   return;
  }

 switch(m_CurrentInstrument)
  {
   case m_Guitar:   s = GenGuitarScale(m_Key);                break;
   case m_Bass:     s = GenBassScale(m_Key);                  break;
   case m_Mandolin: s = GenMandolinScale(m_Key);              break;
   case m_Ukulele:  s = GenUkuleleScale(m_Key);                    break;
   case m_Keyboard: s = GenPianoScale(m_Key, m_CurrentMode);  break;
  }
 document.getElementById('tdScaleInst').innerHTML = s;
}

function showModeChords()
{
 var s;

 s = genModeChords();

 document.getElementById('tdModeChordsTH').innerHTML = s;
}

function hideChords()
{
 var i;

 document.getElementById("tdScaleInst").innerHTML="";
 for (i=0; i<7; i++)
  {
   document.getElementById("tdChord" + i.toString()).innerHTML="";
  }
 return;
}


// tab content button click handler

function openPage(pageNum, pageName, btn) 
{
 var i, tabs, btns;
 
 // Hide all tabContent divs
 tabs = document.getElementsByClassName("tabContent");
 for (i=0; i<tabs.length; i++) 
  {
   tabs[i].style.display = "none";
  }

  // Remove the background color of all tablinks/buttons
 btns = document.getElementsByClassName("tabLink");
 for (i=0; i<btns.length; i++) 
  {
   btns[i].style.color="";
   btns[i].style.backgroundColor = ""; // bg color diverts back to the css class
  }
 

  // Show the specific tab content
 document.getElementById(pageName).style.display = "block";

  // Add the specific color to the button used to open the tab content
 btn.style.backgroundColor = "white";
 btn.style.color = "black";

 switch(pageNum)
  {
   case 0:
    {
    } break;
   case 1:
    {
     dynaModesLoaderTH("cboModesTH");
     showChords();
    } break;
   case 2:
    {
     dynaModesLoaderChord("cboModesChord");
     hideChords();
    } break;
   case 3:
    {
     dynaModesLoaderScale("cboModesScale");
     hideChords();
    } break;
  }
}

// call the constructors

 makeInstruments();
 makeModes();
 makeMidiNotes();
 makeChordPatterns();
 makeChordPatternPlacements();
 makeBarreChordPatterns();

 makeGuitar(); // E2, A2, D3, G3, B3, E4

 makeBass(); // E1, A1, D2, G2

 makeMandolin(); // G3, D4, A4, E5

 makeUkulele(); //  G4, C4, E4, A4

</script>

</head>

<body>
<div class="dialogBase" id="divDialogBase" onclick="eventDialogChordPattern_Click(-1);">
 <div class="dialog" id="divDialog"></div>
</div>
<button class="tabLink" style="width: 12%; font-size: 2.1vw;" onclick="openPage(0, 'divProperties', this)" id="btnDefault">&#9728;</button>
<button class="tabLink" style="width:29%;" onclick="openPage(1, 'divTabHarmony', this)">Harmony</button>
<button class="tabLink" style="width:29%;" onclick="openPage(2, 'divTabChords', this)">Chords</button>
<button class="tabLink" style="width:29%;" onclick="openPage(3, 'divTabScales', this)">Scales</button>

<div id="divProperties" class="tabContent">
<table>
 <tr>
  <th></th>
  <th class="thInst">Instrument</th>
  <th class="thInst">Capo</th>
  <th class="thInst">Tuning</th>
 </tr>
 <tr>
  <td class="tdInst"><input type="radio" name="Inst" id="radGuitar" class="radBtn" onclick="eventRadInstrument(m_Guitar);"></td>
  <td class="tdInst">Guitar</td>
  <td><select id="cboGuitarCapo" onchange="eventcboGuitarCapo_Change();"></select></td>
  <td><select id="cboGuitarTune" onchange="eventcboGuitarTune_Change();"></select></td>
 </tr>
 <tr>
  <td class="tdInst"><input type="radio" name="Inst" id="radBass" class="radBtn" onclick="eventRadInstrument(m_Bass);"></td>
  <td class="tdInst">Bass</td>
  <td><select id="cboBassCapo" onchange="eventcboBassCapo_Change();"></select></td>
  <td><select id="cboBassTune" onchange="eventcboBassTune_Change();"></select></td>
 </tr>
 <tr>
  <td class="tdInst"><input type="radio" name="Inst" id="radMandolin" class="radBtn" onclick="eventRadInstrument(m_Mandolin);"></td>
  <td class="tdInst">Mandolin</td>
  <td><select id="cboMandolinCapo" onchange="eventcboMandolinCapo_Change();"></select></td>
  <td><select id="cboMandolinTune" onchange="eventcboMandolinTune_Change();"></select></td>
 </tr>
 <tr>
  <td class="tdInst"><input type="radio" name="Inst" id="radUkulele" class="radBtn" onclick="eventRadInstrument(m_Ukulele);"></td>
  <td class="tdInst">Ukulele</td>
  <td><select id="cboUkuleleCapo" onchange="eventcboUkuleleCapo_Change();"></select></td>
  <td><select id="cboUkuleleTune" onchange="eventcboUkuleleTune_Change();"></select></td>
 </tr>
  <tr>
  <td class="tdInst"><input type="radio" name="Inst" id="radKeyboard" class="radBtn" onclick="eventRadInstrument(m_Keyboard);"></td>
  <td class="tdInst">Keyboard</td>
  <td></td>
  <td></td>
 </tr>
 <tr>
  <td class="tdInst">
  <td class="tdVersion">Developer Discord Channel: <a target="_blank" href="https://discord.gg/6auAGhj"> https://discord.gg/6auAGhj </a></td>
 </tr>
 <tr>
  <td class="tdInst"></td>
  <td class="tdVersion" id="tdVersion"></td>"
 </tr>
</table>
</div>

<div id="divTabHarmony" class="tabContent">
<table>
 <tr valign=middle>
  <td><select id="cboModesTH" onchange="eventcboModesTH_Change();"></select></td>
  <td><select id="cboKeysTH" title="Choose Key" onchange="eventcboKeysTH_Change();"></select></td>
  <td id='tdModeChordsTH'></td>
 </tr>
</table>
<table>
 <tr>
  <td>
   <table>
    <tr>
     <td class="tdSideChord"></td>
     <td id="tdScaleInst"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord0" class="tdSideChord"></td>
     <td id="tdChordInst0"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord1" class="tdSideChord"></td>
     <td id="tdChordInst1"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord2" class="tdSideChord"></td>
     <td id="tdChordInst2"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord3" class="tdSideChord"></td>
     <td id="tdChordInst3"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord4" class="tdSideChord"></td>
     <td id="tdChordInst4"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord5" class="tdSideChord"></td>
     <td id="tdChordInst5"></td>
    </tr>
   </table>
 </td>
 </tr>
 <tr>
  <td>
   <table>
    <tr>
     <td id="tdChord6" class="tdSideChord"></td>
     <td id="tdChordInst6"></td>
    </tr>
   </table>
 </td>
 </tr>
</table>
</div>

<div id="divTabChords" class="tabContent">
<table>
 <tr valign=middle>
  <td><select id="cboModesChord" onchange="eventcboModesChord_Change();"></select></td>
  <td><select id="cboKeysChord" title="Choose Key" onchange="eventcboKeysChord_Change();"></select></td>
  <td id='tdChordRoots'></td>
  <td><input class="btn" type="button" value="Clear" onclick="eventBtnChordClear_Click();">
 </tr>
</table>
<table id="tableChords">
</table>
</div>

<div id="divTabScales" class="tabContent">
<table>
 <tr valign=middle>
  <td><select id="cboModesScale" onchange="eventcboModesScale_Change();"></select></td>
  <td><select id="cboKeysScale" title="Choose Key" onchange="eventcboKeysScale_Change();"></select></td>
  <td><input class="btn" type="button" value="Add" onclick="eventBtnScaleAdd_Click();"></td>
  <td><input class="btn" type="button" value="Clear" onclick="eventBtnScaleClear_Click();"></td>
 </tr>
</table>
<table id="tableScales">
</table>
</div>
<script type="text/javascript">

 // after document is loaded 

 document.getElementById("btnDefault").click();  // open default tab
 document.getElementById("radGuitar").checked = true;
 m_CurrentInstrument = m_Guitar;

 dynaCapoLoader();
 dynaTuneLoader();

 document.getElementById("tdVersion").innerHTML = "Music Reference Copyright © 2023 Brian L Hughes Version " + m_Version;

</script>
</body>
</html>